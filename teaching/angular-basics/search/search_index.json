{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Angular alapismeretek jegyzet \u00b6 Sz\u00fcks\u00e9ges el\u0151ismeretek \u00b6 HTML \u00e9s CSS alapismeretek JavaScript szintaxis\u00e1nak ismerete (gyorstalpal\u00f3 a 00. fejezetben ) Programoz\u00e1si ismeretek (programoz\u00e1sbeli alapfogalmak, vez\u00e9rl\u00e9si szerkezetek, adatszerkezetek, objektumorient\u00e1lt paradigma ismerete) N\u00e9h\u00e1ny javasolt szerkeszt\u0151program \u00b6 Visual Studio Code WebStorm Atom Brackets Sublime Text Editor A jegyzet tematik\u00e1ja \u00b6 JavaScript gyorstalpal\u00f3 A sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k telep\u00edt\u00e9se Az Angular projektek fel\u00e9p\u00edt\u00e9se ... Az elk\u00e9sz\u00fclt jegyzetr\u0151l, hib\u00e1k \u00b6 Hib\u00e1k \u00b6 Amennyiben az Olvas\u00f3 a jegyzetben b\u00e1rmilyen hib\u00e1t, hi\u00e1nyoss\u00e1got, elg\u00e9pel\u00e9st tal\u00e1l, akkor ezeket a cservenak99[kukac]gmail[pont]com e-mail c\u00edmen jelezheti a k\u00e9sz\u00edt\u0151nek. El\u0151re is k\u00f6sz\u00f6n\u00f6m a mindenf\u00e9le \u00e9szrev\u00e9teleket, megjegyz\u00e9seket a jegyzettel kapcsolatban! K\u00e9sz\u00edt\u0151 \u00b6 Cserven\u00e1k Bence Jogi nyilatkozat \u00b6 Nevezd meg! - Ne add el! - \u00cdgy add tov\u00e1bb! 4.0 Nemzetk\u00f6zi Gyors \u00f6sszefoglal\u00f3 a licenszr\u0151l, \u00e9s a teljes v\u00e1ltozat .","title":"Kezd\u0151lap"},{"location":"#angular-alapismeretek-jegyzet","text":"","title":"Angular alapismeretek jegyzet"},{"location":"#szukseges-eloismeretek","text":"HTML \u00e9s CSS alapismeretek JavaScript szintaxis\u00e1nak ismerete (gyorstalpal\u00f3 a 00. fejezetben ) Programoz\u00e1si ismeretek (programoz\u00e1sbeli alapfogalmak, vez\u00e9rl\u00e9si szerkezetek, adatszerkezetek, objektumorient\u00e1lt paradigma ismerete)","title":"Sz\u00fcks\u00e9ges el\u0151ismeretek"},{"location":"#nehany-javasolt-szerkesztoprogram","text":"Visual Studio Code WebStorm Atom Brackets Sublime Text Editor","title":"N\u00e9h\u00e1ny javasolt szerkeszt\u0151program"},{"location":"#a-jegyzet-tematikaja","text":"JavaScript gyorstalpal\u00f3 A sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k telep\u00edt\u00e9se Az Angular projektek fel\u00e9p\u00edt\u00e9se ...","title":"A jegyzet tematik\u00e1ja"},{"location":"#az-elkeszult-jegyzetrol-hibak","text":"","title":"Az elk\u00e9sz\u00fclt jegyzetr\u0151l, hib\u00e1k"},{"location":"#hibak","text":"Amennyiben az Olvas\u00f3 a jegyzetben b\u00e1rmilyen hib\u00e1t, hi\u00e1nyoss\u00e1got, elg\u00e9pel\u00e9st tal\u00e1l, akkor ezeket a cservenak99[kukac]gmail[pont]com e-mail c\u00edmen jelezheti a k\u00e9sz\u00edt\u0151nek. El\u0151re is k\u00f6sz\u00f6n\u00f6m a mindenf\u00e9le \u00e9szrev\u00e9teleket, megjegyz\u00e9seket a jegyzettel kapcsolatban!","title":"Hib\u00e1k"},{"location":"#keszito","text":"Cserven\u00e1k Bence","title":"K\u00e9sz\u00edt\u0151"},{"location":"#jogi-nyilatkozat","text":"Nevezd meg! - Ne add el! - \u00cdgy add tov\u00e1bb! 4.0 Nemzetk\u00f6zi Gyors \u00f6sszefoglal\u00f3 a licenszr\u0151l, \u00e9s a teljes v\u00e1ltozat .","title":"Jogi nyilatkozat"},{"location":"00_js_recap/","text":"00. JavaScript gyorstalpal\u00f3 \u00b6 Mivel az Angular egy JavaScript keretrendszer, ez\u00e9rt fontos, hogy valamennyire tiszt\u00e1ban legy\u00fcnk a JavaScript nyelv szintaxis\u00e1val, alapvet\u0151 elemeivel. Ebben a fejezetben v\u00e1zlatosan \u00e1ttekintj\u00fck a JavaScripttel kapcsolatos fontosabb ismereteket. A fejezet csup\u00e1n kieg\u00e9sz\u00edt\u00e9sk\u00e9nt szolg\u00e1l a jegyzethez, \u00edgy azok, akik m\u00e1r rutinosan mozognak a JavaScript vil\u00e1g\u00e1ban, nyugodtan \u00e1tugorhatj\u00e1k ezt a r\u00e9szt. JavaScript k\u00f3d \u00edr\u00e1sa \u00e9s futtat\u00e1sa \u00b6 A JavaScript k\u00f3dot be\u00e1gyazhatjuk HTML dokumentumokba \u00e9s futtathatjuk azt b\u00f6ng\u00e9sz\u0151ben. Egy m\u00e1sik opci\u00f3 a Node.js futtat\u00f3k\u00f6rnyezet haszn\u00e1lata. Ekkor nem kell a JavaScript k\u00f3dunkhoz semmilyen \"HTML k\u00f6r\u00edt\u00e9st\" \u00edrnunk, hanem parancssorb\u00f3l tudjuk futtatni azt. T\u00f6lts\u00fck le innen a Node.js LTS (Long Term Support) verzi\u00f3j\u00e1t, majd telep\u00edts\u00fck azt! Az \u00e1ltalunk \u00edrt JavaScript k\u00f3dot ments\u00fck el egy .js kiterjeszt\u00e9s\u0171 f\u00e1jlba! A f\u00e1jlban l\u00e9v\u0151 k\u00f3dot a node fajlnev.js parancs kiad\u00e1s\u00e1val futtassuk parancssorb\u00f3l! Szintaxis, alapvet\u0151 nyelvi elemek \u00b6 A JavaScript utas\u00edt\u00e1sok v\u00e9g\u00e9re nem k\u00f6telez\u0151 pontosvessz\u0151t tenni, viszont bizonyos esetekben a pontosvessz\u0151 elhagy\u00e1sa nem v\u00e1rt m\u0171k\u00f6d\u00e9st eredm\u00e9nyezhet. Emiatt c\u00e9lszer\u0171 a pontosvessz\u0151t mindig kitenni az utas\u00edt\u00e1sok v\u00e9g\u00e9re! Kommentek (Megjegyz\u00e9sek) \u00b6 1 2 3 4 5 6 // ez egy egysoros komment /* ez egy t\u00f6bb soros komment */ Ki\u00edrat\u00e1sok \u00b6 console.log() : konzolra \u00edr\u00e1s (Node.js haszn\u00e1lata eset\u00e9n a parancssor-ablakra \u00edr, b\u00f6ng\u00e9sz\u0151s k\u00f6rnyezetben pedig a fejleszt\u0151i konzolra) alert() : felugr\u00f3 ablak (csak b\u00f6ng\u00e9sz\u0151s k\u00f6rnyezetben m\u0171k\u00f6dik) 1 2 console . log ( \"Hello World!\" ); console . log ( \"T\u00f6bb\" , \"param\u00e9ter\" , \"is\" , \"\u00e1tadhat\u00f3.\" ); A k\u00f3d kimenete Hello World! T\u00f6bb param\u00e9ter is \u00e1tadhat\u00f3. Alapvet\u0151 adatt\u00edpusok \u00b6 Boolean: logikai adatt\u00edpus Lehets\u00e9ges \u00e9rt\u00e9kei: true (igaz) vagy false (hamis) Number: sz\u00e1m adatt\u00edpus Az eg\u00e9sz \u00e9s a lebeg\u0151pontos sz\u00e1mok t\u00edpusa (JavaScriptben nincs k\u00fcl\u00f6n int \u00e9s float) Minden sz\u00e1mot lebeg\u0151pontosk\u00e9nt \u00e1br\u00e1zol (sok esetben pazarl\u00f3) String: sz\u00f6veges adatt\u00edpus Sz\u00f6vegek megad\u00e1sa: aposztr\u00f3fok ( '...' ) vagy id\u00e9z\u0151jelek ( \"...\" ) k\u00f6z\u00f6tt Stringek \u00f6sszef\u0171z\u00e9se: + oper\u00e1torral Undefined: speci\u00e1lis adatt\u00edpus, egyetlen lehets\u00e9ges \u00e9rt\u00e9ke az undefined Az inicializ\u00e1l\u00e1s n\u00e9lk\u00fcli v\u00e1ltoz\u00f3k \u00e9rt\u00e9ke undefined A nem megadott f\u00fcggv\u00e9nyparam\u00e9terek \u00e9rt\u00e9ke undefined Egy objektum nem l\u00e9tez\u0151 adattagj\u00e1ra val\u00f3 hivatkoz\u00e1s eset\u00e9n undefined -ot kapunk T\u00edpuskonverzi\u00f3k \u00b6 JavaScriptben a t\u00edpusok k\u00f6z\u00f6tti konverzi\u00f3 automatikusan t\u00f6rt\u00e9nik. K\u00e9t p\u00e9lda automatikus t\u00edpuskonverzi\u00f3ra: Ha a + oper\u00e1tor b\u00e1rmelyik operandusa string, akkor a m\u00e1sik operandust is stringre konvert\u00e1lja, \u00e9s \u00f6sszef\u0171zi a k\u00e9t stringet. Ha a * oper\u00e1tor valamelyik operandusa nem sz\u00e1m t\u00edpus\u00fa, akkor megpr\u00f3b\u00e1lja azt sz\u00e1mm\u00e1 konvert\u00e1lni. Ha az \u00e1talak\u00edt\u00e1s sikeres, akkor elv\u00e9gezz\u00fck a szorz\u00e1st, k\u00fcl\u00f6nben pedig NaN -t kapunk vissza (Not a Number). 1 2 3 \"2\" + 5 ; // \"2\" + \"5\" = \"25\" \"2\" * 5 ; // 2 * 5 = 10 \"sajt\" * 5 ; // NaN (Not a Number) Az automatikus t\u00edpuskonverzi\u00f3 mellett egy m\u00e1sik lehet\u0151s\u00e9g a typecasting (t\u00edpusk\u00e9nyszer\u00edt\u00e9s) : Boolean(expr) : az expr kifejez\u00e9st boolean t\u00edpus\u00fav\u00e1 alak\u00edtja Number(expr) : az expr kifejez\u00e9st number t\u00edpus\u00fav\u00e1 alak\u00edtja String(expr) : az expr kifejez\u00e9st string t\u00edpus\u00fav\u00e1 alak\u00edtja. A sz\u00e1mok k\u00f6z\u00f6tti konverzi\u00f3ra haszn\u00e1lhatjuk m\u00e9g a parseInt() (eg\u00e9sz \u00e9rt\u00e9kre konvert\u00e1l\u00e1s) \u00e9s a parseFloat() (lebeg\u0151pontos \u00e9rt\u00e9kre konvert\u00e1l\u00e1s) be\u00e9p\u00edtett f\u00fcggv\u00e9nyeket is. 1 2 3 4 5 Number ( \"3.14\" ); // 3.14 Number ( \"101 kiskutya\" ); // NaN (Not a Number) parseInt ( 3.14 ); // 3 String ( 42 ); // \"42\" Boolean ( 0 ); // false V\u00e1ltoz\u00f3k \u00b6 JavaScriptben hagyom\u00e1nyos v\u00e1ltoz\u00f3 l\u00e9trehoz\u00e1sra \u00e1ltal\u00e1ban a let kulcssz\u00f3t haszn\u00e1ljuk. A const kulcssz\u00f3val konstans v\u00e1ltoz\u00f3kat is l\u00e9trehozhatunk, amelyek kezd\u0151\u00e9rt\u00e9ke nem m\u00f3dos\u00edthat\u00f3. Megjegyz\u00e9s A let \u00e9s const kulcsszavakat a 2015-\u00f6s ECMAScript6 (ES6) szabv\u00e1ny vezette be. Kor\u00e1bban a var kulcssz\u00f3t haszn\u00e1ltuk v\u00e1ltoz\u00f3k l\u00e9trehoz\u00e1s\u00e1ra, ami egy\u00e9bk\u00e9nt a mai napig jelen van a nyelvben. Mivel viszont a var -nak van mindenf\u00e9le ny\u0171gje, ez\u00e9rt \u00e9rdemes nem azt haszn\u00e1lni a v\u00e1ltoz\u00f3l\u00e9trehoz\u00e1sra! 1 2 3 4 5 6 let nev = \"B\u00e9la\" ; // v\u00e1ltoz\u00f3 l\u00e9trehoz\u00e1sa console . log ( \"Hello! A nevem\" , nev ); const eletErtelme = 42 ; // konstans v\u00e1ltoz\u00f3 l\u00e9trehoz\u00e1sa console . log ( \"Az \u00e9let \u00e9rtelme:\" , eletErtelme ); // eletErtelme = 10; // HIBA: konstans v\u00e1ltoz\u00f3 \u00e9rt\u00e9ke nem m\u00f3dos\u00edthat\u00f3! A k\u00f3d kimenete Hello! A nevem B\u00e9la Az \u00e9let \u00e9rtelme: 42 Dinamikus t\u00edpusoss\u00e1g \u00b6 Az el\u0151z\u0151 k\u00f3dban \u00e9szrevehett\u00fck, hogy (C-vel ellent\u00e9tben) a v\u00e1ltoz\u00f3k l\u00e9trehoz\u00e1sakor nem \u00edrjuk ki expliciten a v\u00e1ltoz\u00f3t\u00edpust. Ennek az az oka, hogy a JavaScript egy dinamikusan t\u00edpusos nyelv , ami azt jelenti, hogy a JavaScript \u00e9rtelmez\u0151 automatikusan \"ki tudja tal\u00e1lni\" a v\u00e1ltoz\u00f3k t\u00edpus\u00e1t a benn\u00fck t\u00e1rolt \u00e9rt\u00e9k alapj\u00e1n. A dinamikus t\u00edpusoss\u00e1g egyik \u00e9rdekes k\u00f6vetkezm\u00e9nye, hogy ugyanabban a v\u00e1ltoz\u00f3ban ak\u00e1r elt\u00e9r\u0151 t\u00edpus\u00fa adatokat is t\u00e1rolhatunk. Erre l\u00e1thatunk p\u00e9ld\u00e1t az al\u00e1bbi k\u00f3dban. 1 2 3 4 let val = 42 ; // val t\u00edpusa: number val = true ; // val t\u00edpusa: boolean val = undefined ; // val t\u00edpusa: undefined val = \"sajt\" ; // val t\u00edpusa: string Fontosabb oper\u00e1torok \u00b6 Aritmetikai oper\u00e1torok: + (\u00f6sszead\u00e1s), - (kivon\u00e1s), * (szorz\u00e1s), / (val\u00f3s oszt\u00e1s), % (marad\u00e9kos oszt\u00e1s), ** (hatv\u00e1nyoz\u00e1s) Hozz\u00e1rendel\u0151 oper\u00e1torok: = , += , -= , *= , /= (ugyan\u00fagy m\u0171k\u00f6dnek, mint C-ben) Inkrement\u00e1l\u00f3, dekrement\u00e1l\u00f3 oper\u00e1torok: ++ , -- (ugyan\u00fagy m\u0171k\u00f6dnek, mint C-ben) \u00d6sszehasonl\u00edt\u00f3 oper\u00e1torok: == (azonos \u00e9rt\u00e9k), === (azonos \u00e9rt\u00e9k \u00e9s t\u00edpus), != (elt\u00e9r\u0151 \u00e9rt\u00e9k), !== (elt\u00e9r\u0151 \u00e9rt\u00e9k vagy t\u00edpus), < (kisebb), <= (kisebb vagy egyenl\u0151), > (nagyobb), >= (nagyobb vagy egyenl\u0151) Logikai oper\u00e1torok: && (logikai \u00c9S), || (logikai VAGY), ! (logikai NEM) Szeml\u00e9ltess\u00fck egy p\u00e9ld\u00e1n a == \u00e9s === oper\u00e1torok k\u00f6z\u00f6tti m\u0171k\u00f6d\u00e9sbeli k\u00fcl\u00f6nbs\u00e9get! Hasonl\u00edtsunk \u00f6ssze k\u00e9t kifejez\u00e9st, amelyre a k\u00e9t oper\u00e1tor elt\u00e9r\u0151 \u00e9rt\u00e9ket ad vissza! P\u00e9ld\u00e1ul: 1 2 console . log ( 0 == false ); // true console . log ( 0 === false ); // false Mi is t\u00f6rt\u00e9nik itt? Mivel egy sz\u00e1mot hasonl\u00edtunk \u00f6ssze egy logikai \u00e9rt\u00e9kkel, ez\u00e9rt a JavaScript automatikus t\u00edpuskonverzi\u00f3t v\u00e9gez. A t\u00edpuskonverzi\u00f3t k\u00f6vet\u0151en a k\u00e9t kifejez\u00e9s \u00e9rt\u00e9ke megegyezik (hiszen m\u00e1r C-b\u0151l tudjuk, hogy a 0 sz\u00e1m\u00e9rt\u00e9k a false logikai \u00e9rt\u00e9knek felel meg), ez\u00e9rt a == oper\u00e1tor igazat ad vissza. Viszont mivel a kifejez\u00e9sek t\u00edpusa elt\u00e9r (a 0 number, m\u00edg a false boolean t\u00edpus\u00fa), ez\u00e9rt a === oper\u00e1tor hamisat ad vissza. JavaScriptben a / oper\u00e1tor alapb\u00f3l val\u00f3s oszt\u00e1st v\u00e9gez. Hogyan val\u00f3s\u00edtan\u00e1nk meg az eg\u00e9szoszt\u00e1st? Mivel l\u00e9nyeg\u00e9ben az oszt\u00e1s ut\u00e1n kapott tizedes t\u00f6rt eg\u00e9szr\u00e9sz\u00e9re vagyunk k\u00edv\u00e1ncsiak, ez\u00e9rt csak a val\u00f3s oszt\u00e1ssal kapott \u00e9rt\u00e9ket kell lefel\u00e9 kerek\u00edten\u00fcnk. A lefel\u00e9 kerek\u00edt\u00e9sre a Math.floor() f\u00fcggv\u00e9nyt haszn\u00e1ljuk. 1 2 const egeszResz = Math . floor ( 5 / 2 ); console . log ( egeszResz ); // 2 A Math objektum egy\u00e9bk\u00e9nt rengeteg hasznos matematikai f\u00fcggv\u00e9nyt \u00e9s konstanst biztos\u00edt a sz\u00e1munkra. Err\u0151l b\u0151vebben ezen a linken olvashatunk. Vez\u00e9rl\u00e9si szerkezetek \u00b6 A szelekci\u00f3s vez\u00e9rl\u00e9s megval\u00f3s\u00edt\u00e1s\u00e1ra az if , else if , else \u00e9s switch utas\u00edt\u00e1sokat haszn\u00e1lhatjuk. Ezek ugyan\u00fagy m\u0171k\u00f6dnek, mint C-ben. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 let szam = 5 ; if ( szam < 0 ) { console . log ( \"A sz\u00e1m negat\u00edv.\" ); } else if ( szam === 0 ) { console . log ( \"A sz\u00e1m nulla.\" ); } else { console . log ( \"Pozit\u00edv.\" ); } switch ( szam ) { case 1 : console . log ( \"El\u00e9gtelen.\" ); break ; case 2 : console . log ( \"El\u00e9gs\u00e9ges.\" ); break ; case 3 : console . log ( \"K\u00f6zepes.\" ); break ; case 4 : console . log ( \"J\u00f3.\" ); break ; case 5 : console . log ( \"Jeles.\" ); break ; default : console . log ( \"\u00c9rv\u00e9nytelen \u00e9rt\u00e9k!\" ); } A k\u00f3d kimenete Pozit\u00edv. Jeles. Az egyetlen if -b\u0151l \u00e9s az ahhoz tartoz\u00f3 else -b\u0151l \u00e1ll\u00f3 felt\u00e9telek megad\u00e1s\u00e1ra a C-b\u0151l ismer\u0151s ternary oper\u00e1tor is haszn\u00e1lhat\u00f3. Ennek a szintaxisa a szok\u00e1sos: <felt\u00e9tel> ? <m\u0171velet, ha igaz> : <m\u0171velet, ha hamis> . 1 2 let eletkor = 12 ; console . log ( eletkor >= 18 ? \"Nagykor\u00fa vagy.\" : \"M\u00e9g kiskor\u00fa vagy.\" ); A k\u00f3d kimenete M\u00e9g kiskor\u00fa vagy. Az ism\u00e9tl\u00e9ses vez\u00e9rl\u00e9s (ciklusok) megval\u00f3s\u00edt\u00e1s\u00e1ra a while , do... while \u00e9s for utas\u00edt\u00e1sokat haszn\u00e1lhatjuk. Ezek szint\u00e9n ugyan\u00fagy m\u0171k\u00f6dnek, mint C-ben. Gyakorl\u00e1sk\u00e9ppen \u00edrassuk ki az eg\u00e9sz sz\u00e1mokat 1-t\u0151l 10-ig mindh\u00e1rom ciklussal! 1 2 3 4 5 6 let i = 1 ; while ( i <= 10 ) { // while-ciklus console . log ( i ); i ++ ; } 1 2 3 4 5 6 let i = 1 ; do { // do...while-ciklus console . log ( i ); i ++ ; } while ( i <= 10 ); 1 2 3 for ( let i = 1 ; i <= 10 ; i ++ ) { // for-ciklus console . log ( i ); } F\u00fcggv\u00e9nyek \u00b6 A f\u00fcggv\u00e9nydefin\u00edci\u00f3 \u00e1ltal\u00e1nos szintaxisa JavaScriptben: 1 2 3 4 function fuggvenyNeve ( param1 , param2 , ...) { // utas\u00edt\u00e1sok... return visszateresiErtek ; // elhagyhat\u00f3! } A f\u00fcggv\u00e9nyh\u00edv\u00e1s \u00e1ltal\u00e1nos szintaxisa JavaScriptben: 1 fuggvenyNeve ( param1 , param2 , ...); Default param\u00e9terek \u00b6 JavaScriptben (Jav\u00e1val ellent\u00e9tben) nem m\u0171k\u00f6dik a f\u00fcggv\u00e9ny overloading (m\u00e9g elt\u00e9r\u0151 param\u00e9terez\u00e9s eset\u00e9n sem). Ha t\u00f6bb azonos nev\u0171 f\u00fcggv\u00e9ny\u00fcnk van, akkor mindig a k\u00f3dban legk\u00e9s\u0151bb defini\u00e1lt f\u00fcggv\u00e9ny lesz h\u00edvhat\u00f3. 1 2 3 4 5 6 7 8 9 10 function hello () { console . log ( \"Szia!\" ); } function hello ( nev ) { // ez a legutolj\u00e1ra l\u00e9trehozott hello() f\u00fcggv\u00e9ny, ez lesz h\u00edvhat\u00f3! console . log ( \"Szia \" + nev + \"!\" ); } hello (); // a nem megadott nev param\u00e9ter \u00e9rt\u00e9ke undefined lesz a f\u00fcggv\u00e9nyh\u00edv\u00e1s sor\u00e1n hello ( \"Tam\u00e1s\" ); A k\u00f3d kimenete Szia undefined! Szia Tam\u00e1s! A default f\u00fcggv\u00e9nyparam\u00e9terek viszont lehet\u0151s\u00e9get biztos\u00edtanak arra, hogy egy f\u00fcggv\u00e9nyt ak\u00e1r elt\u00e9r\u0151 param\u00e9terez\u00e9ssel is haszn\u00e1lhassunk. Ezeknek a l\u00e9nyege, hogy a f\u00fcggv\u00e9ny bizonyos param\u00e9tereinek alap\u00e9rtelmezett \u00e9rt\u00e9ket adunk a f\u00fcggv\u00e9nydefin\u00edci\u00f3kor. Ha a f\u00fcggv\u00e9nyh\u00edv\u00e1skor egy param\u00e9ter \u00e9rt\u00e9k\u00e9t nem adjuk meg, akkor az az alap\u00e9rtelmezett \u00e9rt\u00e9ket veszi fel. 1 2 3 4 5 6 function hello ( nev = \"Senki\" ) { console . log ( \"Szia \" + nev + \"!\" ); } hello (); // mivel nem adtuk \u00e1t a param\u00e9ter \u00e9rt\u00e9k\u00e9t, ez\u00e9rt az a default \u00e9rt\u00e9ket veszi fel hello ( \"Tam\u00e1s\" ); // itt a param\u00e9ter \u00e9rt\u00e9ke term\u00e9szetesen az \u00e1tadott \u00e9rt\u00e9k lesz Kimenet Szia Senki! Szia Tam\u00e1s! Ha egy f\u00fcggv\u00e9ny nem minden param\u00e9ter\u00e9nek adunk default \u00e9rt\u00e9ket, akkor a default \u00e9rt\u00e9kkel rendelkez\u0151 param\u00e9terek mindig a param\u00e9terlista jobb oldal\u00e1n kell, hogy szerepljenek (m\u00e1sk\u00e9pp mondva: mindig az utols\u00f3 n\u00e9h\u00e1ny param\u00e9ternek adunk default \u00e9rt\u00e9ket)! 1 2 3 4 5 6 7 function info ( nev , eletkor = 20 , foglalkozas = \"programoz\u00f3\" ) { console . log ( nev + \" egy \" + eletkor + \" \u00e9ves \" + foglalkozas + \".\" ); } info ( \"Sanyi\" ); info ( \"J\u00f3zsi\" , 50 ); info ( \"B\u00e9la\" , 40 , \"asztronauta\" ); A k\u00f3d kimenete Sanyi egy 20 \u00e9ves programoz\u00f3. J\u00f3zsi egy 50 \u00e9ves programoz\u00f3. B\u00e9la egy 40 \u00e9ves asztronauta. Callback f\u00fcggv\u00e9nyek \u00b6 JavaScriptben el\u0151fordul, hogy egy f\u00fcggv\u00e9nyt egy m\u00e1sik f\u00fcggv\u00e9ny param\u00e9terek\u00e9nt haszn\u00e1lunk fel. Az ilyen f\u00fcggv\u00e9nyeket nevezz\u00fck callback f\u00fcggv\u00e9nynek . A callback f\u00fcggv\u00e9nyt term\u00e9szetesen meg is h\u00edvhatjuk abban a f\u00fcggv\u00e9nyben, amely param\u00e9ter\u00fcl kapja azt. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Ez lesz majd a callback f\u00fcggv\u00e9ny\u00fcnk, amit megh\u00edvunk egy m\u00e1sik f\u00fcggv\u00e9nyben function feldolgoz () { console . log ( \"Meg\u00e9rkezett az adat! Dolgozzuk fel...\" ); } // Ez a f\u00fcggv\u00e9ny egy 2 m\u00e1sodpercig tart\u00f3 adatlek\u00e9rdez\u00e9st szimul\u00e1l (p\u00e9ld\u00e1ul egy adatb\u00e1zisb\u00f3l) // Amikor az adat meg\u00e9rkezik (letelik a 2 m\u00e1sodperc), megh\u00edvjuk a param\u00e9terben kapott callback f\u00fcggv\u00e9nyt function adatLekerdezes ( callback ) { setTimeout ( callback , 2000 ); // 2 m\u00e1sodperces timeout, majd callback f\u00fcggv\u00e9ny megh\u00edv\u00e1sa console . log ( \"Ajaj, ez hamarabb lefut, mint ahogy meg\u00e9rkezne az adat!\" ); } // F\u00fcggv\u00e9nyh\u00edv\u00e1s, ahol a callback f\u00fcggv\u00e9ny a feldolgoz() f\u00fcggv\u00e9ny lesz adatLekerdezes ( feldolgoz ); Kimenet Ajaj, ez hamarabb lefut, mint ahogy meg\u00e9rkezne az adat! Meg\u00e9rkezett az adat! Dolgozzuk fel... Anonim f\u00fcggv\u00e9nyek \u00e9s arrow function-\u00f6k \u00b6 Az anonim f\u00fcggv\u00e9nyek n\u00e9v n\u00e9lk\u00fcli f\u00fcggv\u00e9nyek, amelyeket kifejez\u00e9sk\u00e9nt defini\u00e1lunk. Ezeket a f\u00fcggv\u00e9ny kifejez\u00e9seket v\u00e1ltoz\u00f3kban is elt\u00e1rolhatjuk, majd amikor meg szeretn\u00e9nk h\u00edvni \u0151ket, akkor a v\u00e1ltoz\u00f3 nev\u00e9vel hivatkozhatunk r\u00e1juk. 1 2 let osszead = function ( a , b ) { return a + b ; } // anonim f\u00fcggv\u00e9ny console . log ( osszead ( 10 , 20 )); // f\u00fcggv\u00e9nyh\u00edv\u00e1s A k\u00f3d kimenete 30 Az ECMAScript6 (ES6) szabv\u00e1nyban bevezett\u00e9k az \u00fagynevezett arrow function -\u00f6ket az anonim f\u00fcggv\u00e9nyek t\u00f6m\u00f6rebb megad\u00e1s\u00e1ra. Szintaxisuk a k\u00f6vetkez\u0151: 1 ( param1 , param2 , ...) => { /* f\u00fcggv\u00e9nyt\u00f6rzs... */ } Ha a f\u00fcggv\u00e9nyt\u00f6rzs egyetlen utas\u00edt\u00e1sb\u00f3l \u00e1ll, akkor a { \u00e9s } szabadon elhagyhat\u00f3. Ha a f\u00fcggv\u00e9nyt\u00f6rzs egyetlen return utas\u00edt\u00e1sb\u00f3l \u00e1ll, akkor a return kulcssz\u00f3 elhagyhat\u00f3. Ha a f\u00fcggv\u00e9ny\u00fcnk nem v\u00e1r param\u00e9tert, akkor a => el\u0151tti z\u00e1r\u00f3jelp\u00e1rt \u00fcresen hagyjuk. Ha a f\u00fcggv\u00e9ny\u00fcnk egyetlen param\u00e9tert v\u00e1r, akkor a => el\u0151tti z\u00e1r\u00f3jelek elhagyhat\u00f3k. 1 2 3 4 5 6 7 8 9 10 11 12 // 0 param\u00e9tert v\u00e1r\u00f3 arrow function let koszontes = () => { console . log ( \"Halih\u00f3!\" ); console . log ( \"Ez egy p\u00e9ldaprogram arrow function-\u00f6kre.\" ); } // 1 param\u00e9tert v\u00e1r\u00f3 arrow function let uvolt = szoveg => console . log ( szoveg . toUpperCase () + \"!!!\" ); // 2 param\u00e9tert v\u00e1r\u00f3 arrow function let hatvanyoz = ( alap , kitevo ) => alap ** kitevo ; // ugyanaz, mint (alap, kitevo) => { return alap ** kitevo; } koszontes (); uvolt ( \"aaaaa\" ); console . log ( hatvanyoz ( 2 , 10 )); A k\u00f3d kimenete Halih\u00f3! Ez egy p\u00e9ldaprogram arrow function-\u00f6kre. AAAAA!!! 1024 Stringek (Sz\u00f6vegek) \u00b6 Megad\u00e1suk: \u00e1ltal\u00e1ban aposztr\u00f3fok ( '...' ) vagy id\u00e9z\u0151jelek ( \"...\" ) k\u00f6z\u00f6tt t\u00f6bb soros sz\u00f6vegeket backtick-ek k\u00f6z\u00f6tt adhatunk meg (magyar billenty\u0171zeten az AltGr + 7 billenty\u0171kombin\u00e1ci\u00f3val \u00edrhatunk backtick-et) 1 2 3 4 5 6 7 let egysoros1 = 'Ez egy sz\u00f6veg' ; let egysoros2 = \"Ez egy m\u00e1sik sz\u00f6veg\" ; let tobbsoros = `Never gonna give you up Never gonna let you down Never gonna run around And desert you` ; Stringek \u00f6sszef\u0171z\u00e9se: + oper\u00e1torral String hossz\u00e1nak lek\u00e9rdez\u00e9se: length property-vel 1 2 3 let szoveg = \"kecske\" + \"sajt\" ; // stringek \u00f6sszef\u0171z\u00e9se console . log ( szoveg ); console . log ( szoveg . length ); // string hossz\u00e1nak lek\u00e9rdez\u00e9se A k\u00f3d kimenete kecskesajt 10 Karakterek indexel\u00e9se: [] oper\u00e1torral, 0-t\u00f3l kezd\u0151d\u0151en JavaScriptben a string egy immutable adatt\u00edpus , azaz a sz\u00f6vegek a l\u00e9trehoz\u00e1s ut\u00e1n nem v\u00e1ltoztathat\u00f3k meg (teh\u00e1t pl. nem lehet egy string egy adott karakter\u00e9t m\u00f3dos\u00edtani) 1 2 3 4 5 6 let szoveg = \"kecskesajt\" ; console . log ( \"Az els\u0151 karakter: \" + szoveg [ 0 ]); console . log ( \"Az utols\u00f3 karakter: \" + szoveg [ szoveg . length - 1 ]); szoveg [ 0 ] = 'F' ; // ennek JavaScriptben nincs hat\u00e1sa (minden string immutable!) console . log ( szoveg ); A k\u00f3d kimenete Az els\u0151 karakter: k Az utols\u00f3 karakter: t kecskesajt N\u00e9h\u00e1ny stringkezel\u0151 f\u00fcggv\u00e9ny (teljes lista itt ): s.toLowerCase() : csupa kisbet\u0171ss\u00e9 alak\u00edtja az s stringet s.toUpperCase() : csupa nagybet\u0171ss\u00e9 alak\u00edtja az s stringet s.startsWith(t) : igazat ad vissza, ha az s string a t r\u00e9szsz\u00f6veggel kezd\u0151dik s.endsWith(t) : igazat ad vissza, ha az s string a t r\u00e9szsz\u00f6vegre v\u00e9gz\u0151dik s.trim() : elt\u00e1vol\u00edtja a whitespace karaktereket az s string elej\u00e9r\u0151l \u00e9s v\u00e9g\u00e9r\u0151l s.substring(start, end) : visszaad az s stringb\u0151l egy r\u00e9szstringet, a start index\u0171 karaktert\u0151l kezdve az end index\u0171 karakterig s.indexOf(t) : visszaadja a t r\u00e9szstring legels\u0151 el\u0151fordul\u00e1s\u00e1nak kezd\u0151index\u00e9t az s stringen bel\u00fcl ( -1 -et ad vissza, ha t nem szerepel az s stringben) s.split(sep) : feldarabolja az s stringet sep karakterek ment\u00e9n (egy t\u00f6mb\u00f6t ad vissza) 1 2 3 4 5 6 7 8 9 10 11 12 let szoveg = \" Ez egy p\u00e9ldasz\u00f6veg, amely t\u00f6bb sz\u00f3b\u00f3l \u00e1ll \" ; szoveg = szoveg . trim (); // whitespace karakterek elt\u00e1vol\u00edt\u00e1sa a sz\u00f6veg elej\u00e9r\u0151l \u00e9s v\u00e9g\u00e9r\u0151l console . log ( szoveg . toUpperCase ()); // nagybet\u0171s\u00edt\u00e9s console . log ( szoveg . endsWith ( \"\u00e1ll\" )); // az \"\u00e1ll\" stringre v\u00e9gz\u0151dik-e a sz\u00f6veg console . log ( szoveg . substring ( 12 , 18 )); // karakterek lek\u00e9r\u00e9se a 12.-t\u0151l a 18. indexig if ( szoveg . indexOf ( \"p\u00e9lda\" ) >= 0 ) // r\u00e9szstring el\u0151fordul\u00e1s\u00e1nak vizsg\u00e1lata console . log ( \"A sz\u00f6vegben szerepel a 'p\u00e9lda' r\u00e9szstring.\" ); let szavak = szoveg . split ( \" \" ); // sz\u00f6veg feldarabol\u00e1sa sz\u00f3k\u00f6z\u00f6k ment\u00e9n console . log ( szavak ); A k\u00f3d kimenete EZ EGY P\u00c9LDASZ\u00d6VEG, AMELY T\u00d6BB SZ\u00d3B\u00d3L \u00c1LL true sz\u00f6veg A sz\u00f6vegben szerepel a 'p\u00e9lda' r\u00e9szstring. [ 'Ez', 'egy', 'p\u00e9ldasz\u00f6veg,', 'amely', 't\u00f6bb', 'sz\u00f3b\u00f3l', '\u00e1ll' ] Template stringek \u00b6 Ha egy strinben be szeretn\u00e9nk helyettes\u00edteni k\u00fcl\u00f6nf\u00e9le kifejez\u00e9sek \u00e9rt\u00e9k\u00e9t, akkor hagyom\u00e1nyos string\u00f6sszef\u0171z\u00e9sek helyett haszn\u00e1lhatjuk az ES6 szabv\u00e1nyban bevezetett template stringeket . A template stringeket backtick-ek k\u00f6z\u00e9 \u00edrjuk, a behelyettes\u00edtend\u0151 \u00e9rt\u00e9keket ${ } seg\u00edts\u00e9g\u00e9vel adjuk meg a template stringen bel\u00fcl. 1 2 3 4 5 6 7 let nev = \"B\u00e9la\" , eletkor = 25 , foglalkozas = \"programoz\u00f3\" ; // 1. megold\u00e1s: hagyom\u00e1nyos string\u00f6sszef\u0171z\u00e9s (nem a legk\u00e9nyelmesebb...) console . log ( nev + \" egy \" + eletkor + \" \u00e9ves \" + foglalkozas + \".\" ); // 2. megold\u00e1s: template stringek haszn\u00e1lata (eleg\u00e1ns \u00e9s k\u00e9nyelmes) console . log ( ` ${ nev } egy ${ eletkor } \u00e9ves ${ foglalkozas } .` ); A k\u00f3d kimenete B\u00e9la egy 25 \u00e9ves programoz\u00f3. B\u00e9la egy 25 \u00e9ves programoz\u00f3. Fontosabb adatszerkezetek \u00b6 T\u00f6mb\u00f6k \u00b6 Tetsz\u0151leges mennyis\u00e9g\u0171, nem felt\u00e9tlen azonos t\u00edpus\u00fa adat t\u00e1rol\u00e1s\u00e1ra alkalmas L\u00e9trehoz\u00e1s: 1 2 3 let t1 = []; // \u00fcres t\u00f6mb let t2 = [ 10 , 20 , 30 , 40 ]; let t3 = [ \"alma\" , \"k\u00f6rte\" , \"szilva\" , \"barack\" ]; T\u00f6mb hossz\u00e1nak lek\u00e9rdez\u00e9se: length property-vel T\u00f6mbelemek indexel\u00e9se: [] oper\u00e1torral, 0-t\u00f3l kezd\u0151d\u0151en A stringekkel ellent\u00e9tben a t\u00f6mb egy mutable adatt\u00edpus, \u00edgy lehet\u0151s\u00e9g\u00fcnk van arra, hogy egy adott index\u0171 t\u00f6mbelem \u00e9rt\u00e9k\u00e9t m\u00f3dos\u00edtsuk 1 2 3 4 5 6 7 let gyumolcsok = [ \"alma\" , \"k\u00f6rte\" , \"szilva\" , \"barack\" ]; console . log ( ` ${ gyumolcsok . length } darab gy\u00fcm\u00f6lcs\u00fcnk van.` ); console . log ( `Az els\u0151 gy\u00fcm\u00f6lcs: ${ gyumolcsok [ 0 ] } ` ); console . log ( `Az utols\u00f3 gy\u00fcm\u00f6lcs: ${ gyumolcsok [ gyumolcsok . length - 1 ] } ` ); gyumolcsok [ 1 ] = \"ban\u00e1n\" ; // ez \u00edgy OK (a t\u00f6mb egy mutable adatt\u00edpus) console . log ( gyumolcsok ); A k\u00f3d kimenete 4 darab gy\u00fcm\u00f6lcs\u00fcnk van. Az els\u0151 gy\u00fcm\u00f6lcs: alma Az utols\u00f3 gy\u00fcm\u00f6lcs: barack [ 'alma', 'ban\u00e1n', 'szilva', 'barack' ] T\u00f6mb\u00f6k bej\u00e1r\u00e1sa: for -ciklussal Hagyom\u00e1nyos, index alap\u00fa for -ciklus vagy Listaszer\u0171 bej\u00e1r\u00e1s ( for - of szintaxis) 1 2 3 4 5 6 7 8 9 10 11 12 13 let gyumolcsok = [ \"alma\" , \"k\u00f6rte\" , \"szilva\" , \"barack\" ]; // hagyom\u00e1nyos, index alap\u00fa for-ciklus (ezt m\u00e1r C-b\u0151l is ismerj\u00fck) for ( let i = 0 ; i < gyumolcsok . length ; i ++ ) { console . log ( gyumolcsok [ i ]); } console . log ( \"------------------------------------\" ); // listaszer\u0171 for-ciklus: a gyumi v\u00e1ltoz\u00f3 rendre felveszi a t\u00f6mbelemek \u00e9rt\u00e9k\u00e9t for ( let gyumi of gyumolcsok ) { console . log ( gyumi ); } N\u00e9h\u00e1ny t\u00f6mbkezel\u0151 f\u00fcggv\u00e9ny (teljes lista itt ): t.pop() : t\u00f6rli az utols\u00f3 elemet a t t\u00f6mbb\u0151l t.push(a, b, ...) : besz\u00farja az a , b , ... elemeket a t t\u00f6mb v\u00e9g\u00e9re t.shift() : t\u00f6rli a legels\u0151 elemet a t t\u00f6mbb\u0151l t.unshift(a, b, ...) : besz\u00farja az a , b , ... elemeket a t t\u00f6mb elej\u00e9re t.sort() : rendezi a t t\u00f6mb elemeit (alapb\u00f3l stringekk\u00e9nt kezeli az elemeket!) t.indexOf(e) : visszaadja az e elem legels\u0151 el\u0151fordul\u00e1s\u00e1nak kezd\u0151index\u00e9t a t t\u00f6mb\u00f6n bel\u00fcl ( -1 -et ad vissza, ha e nem szerepel a t t\u00f6mbben) t.splice(i, count, a, b, ...) : elemek besz\u00far\u00e1sa vagy elemek t\u00f6rl\u00e9se Ha az a , b , ... \u00e9rt\u00e9k\u00e9t nem adjuk meg, akkor a kit\u00f6r\u00f6l a t t\u00f6mb i . index\u00e9t\u0151l kezdve count darab elemet Ha az a , b , ... \u00e9rt\u00e9keket megadjuk, akkor besz\u00farja ezeket a t t\u00f6mbbe, az i . indext\u0151l kezdve; ekkor a count \u00e9rt\u00e9k\u00e9t (a t\u00f6rlend\u0151 elemek sz\u00e1m\u00e1t) 0-ra \u00e1ll\u00edtjuk t.slice(start, end) : visszaadja a t t\u00f6mb start \u00e9s end-1 indexei k\u00f6z\u00f6tti elemeit egy t\u00f6mbben (az end param\u00e9ter elhagyhat\u00f3, ekkor a start -t\u00f3l kezdve az \u00f6sszes \"h\u00e1tral\u00e9v\u0151\" t\u00f6mbelemet kapjuk vissza) t.join(sep) : egy stringg\u00e9 egyes\u00edti a t t\u00f6mb\u00f6t, amiben a t\u00f6mbelemek sep karakterek ment\u00e9n lesznek elv\u00e1lasztva 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 let gyumolcsok = [ \"alma\" , \"k\u00f6rte\" , \"szilva\" , \"barack\" ]; gyumolcsok . pop (); // t\u00f6rl\u00e9s a v\u00e9g\u00e9r\u0151l gyumolcsok . push ( \"ban\u00e1n\" , \"citrom\" ); // besz\u00far\u00e1s a v\u00e9g\u00e9re gyumolcsok . shift (); // t\u00f6rl\u00e9s az elej\u00e9r\u0151l gyumolcsok . unshift ( \"dinnye\" ); // besz\u00far\u00e1s az elej\u00e9re console . log ( gyumolcsok ); gyumolcsok . splice ( 2 , 1 ); // 2. indexen l\u00e9v\u0151 t\u00f6mbelem t\u00f6rl\u00e9se console . log ( gyumolcsok ); console . log ( gyumolcsok . slice ( 1 , 3 )); // t\u00f6mbelemek lek\u00e9r\u00e9se az 1.-t\u0151l a 2. indexig if ( gyumolcsok . indexOf ( \"citrom\" ) >= 0 ) // t\u00f6mbelem el\u0151fordul\u00e1s\u00e1nak vizsg\u00e1lata console . log ( \"Van citrom a t\u00f6mbben!\" ); let gyumolcsSzoveg = gyumolcsok . join ( \", \" ); // t\u00f6mbelemek egyes\u00edt\u00e9se sz\u00f6vegg\u00e9 console . log ( `A gy\u00fcm\u00f6lcseink: ${ gyumolcsSzoveg } .` ); A k\u00f3d kimenete [ 'dinnye', 'k\u00f6rte', 'szilva', 'ban\u00e1n', 'citrom' ] [ 'dinnye', 'k\u00f6rte', 'ban\u00e1n', 'citrom' ] [ 'k\u00f6rte', 'ban\u00e1n' ] Van citrom a t\u00f6mbben! A gy\u00fcm\u00f6lcseink: dinnye, k\u00f6rte, ban\u00e1n, citrom. K\u00e9t tov\u00e1bbi hasznos t\u00f6mbkezel\u0151 f\u00fcggv\u00e9ny: map() \u00e9s filter() A map() egy callback f\u00fcggv\u00e9nyt v\u00e1r param\u00e9terk\u00e9nt, amelyet a t\u00f6mb minden elem\u00e9re v\u00e9grehajt. A callback f\u00fcggv\u00e9ny v\u00e9grehajt\u00e1sa ut\u00e1ni eredm\u00e9nyeket egy \u00faj t\u00f6mbben kapjuk vissza. P\u00e9lda: Adott egy sz\u00e1mokat tartalmaz\u00f3 t\u00f6mb. K\u00e9sz\u00edts\u00fcnk egy \u00faj t\u00f6mb\u00f6t, ami tartalmazza az eredeti t\u00f6mbben szerepl\u0151 sz\u00e1mok n\u00e9gyzet\u00e9t. 1 2 3 4 5 6 7 8 let szamok = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]; // A callback f\u00fcggv\u00e9ny megad\u00e1s\u00e1ra ebben a k\u00f3dban az arrow function-\u00f6s szintaxist haszn\u00e1ltuk // A callback f\u00fcggv\u00e9nynek egyetlen param\u00e9tere van (szam), amely mindig az aktu\u00e1lis t\u00f6mbelemet jelk\u00e9pezi // Vessz\u00fck a szamok t\u00f6mb minden elem\u00e9nek a n\u00e9gyzet\u00e9t \u00e9s bepakolgatjuk ezeket egy negyzetszamok nev\u0171 t\u00f6mbbe let negyzetszamok = szamok . map ( szam => szam * szam ); console . log ( negyzetszamok ); // [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] A filter() szint\u00e9n egy callback f\u00fcggv\u00e9nyt v\u00e1r param\u00e9terk\u00e9nt, \u00e9s a t\u00f6mbb\u0151l kiv\u00e1logatja azokat az elemeket, amelyek eleget tesznek a f\u00fcggv\u00e9ny t\u00f6rzs\u00e9ben megadott felt\u00e9telnek. A kiv\u00e1logatott elemeket egy \u00faj t\u00f6mbben kapjuk vissza. P\u00e9lda: Adott egy sz\u00e1mokat tartalmaz\u00f3 t\u00f6mb. V\u00e1logassuk ki a p\u00e1ros sz\u00e1mokat egy \u00faj t\u00f6mbbe! 1 2 3 4 5 6 7 8 let szamok = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]; // A callback f\u00fcggv\u00e9ny megad\u00e1s\u00e1ra ebben a k\u00f3dban az arrow function-\u00f6s szintaxist haszn\u00e1ltuk // A callback f\u00fcggv\u00e9nynek egyetlen param\u00e9tere van (szam), amely mindig az aktu\u00e1lis t\u00f6mbelemet jelk\u00e9pezi // A f\u00fcggv\u00e9ny t\u00f6rzs\u00e9ben megviszg\u00e1ljuk, hogy p\u00e1ros-e a sz\u00e1m, majd a p\u00e1ros sz\u00e1mokat kigy\u0171jtj\u00fck egy parosSzamok nev\u0171 t\u00f6mbbe let parosSzamok = szamok . filter ( szam => szam % 2 === 0 ); console . log ( parosSzamok ); // [2, 4, 6, 8, 10] Megjegyz\u00e9s: A p\u00e9ld\u00e1kban szerepl\u0151 feladatokat term\u00e9szetesen megoldhattuk volna hagyom\u00e1nyos m\u00f3don: vez\u00e9rl\u00e9si szerkezetekkel \u00e9s egy (kezdetben \u00fcres) t\u00f6mbbe val\u00f3 besz\u00farogat\u00e1ssal is. Viszont a map() \u00e9s filter() f\u00fcggv\u00e9nyek ismerete jelent\u0151sen egyszer\u0171bb k\u00f3dot eredm\u00e9nyez. Objektumok \u00b6 Az object adatt\u00edpussal property-\u00e9rt\u00e9k p\u00e1rokat t\u00e1rol\u00f3 objektumokat hozhatunk l\u00e9tre (a property-k tulajdonk\u00e9ppen az objektum adattagjai) L\u00e9trehoz\u00e1s: 1 2 let ures = {}; // \u00fcres objektum let szemely = { nev : \"B\u00e9la\" , kor : 20 , foglalkozas : \"programoz\u00f3\" }; Adott property-hez tartoz\u00f3 \u00e9rt\u00e9k lek\u00e9rdez\u00e9se: . vagy [] oper\u00e1torokkal A k\u00fcl\u00f6nbs\u00e9g a k\u00e9t oper\u00e1tor k\u00f6z\u00f6tt: ha egy v\u00e1ltoz\u00f3t adunk \u00e1t nekik, akkor a . oper\u00e1tor a v\u00e1ltoz\u00f3 nev\u00e9t , m\u00edg a [] oper\u00e1tor a v\u00e1ltoz\u00f3 \u00e9rt\u00e9k\u00e9t tekinti a property nev\u00e9nek Ha egy nem l\u00e9tez\u0151 property-hez tartoz\u00f3 \u00e9rt\u00e9ket k\u00e9r\u00fcnk le, akkor undefined -ot kapunk 1 2 3 4 5 6 7 8 let szemely = { nev : \"B\u00e9la\" , kor : 20 , foglalkozas : \"programoz\u00f3\" }; console . log ( szemely . nev ); // a nev property-hez tartoz\u00f3 \u00e9rt\u00e9k lek\u00e9r\u00e9se (1. verzi\u00f3) console . log ( szemely [ \"nev\" ]); // a nev property-hez tartoz\u00f3 \u00e9rt\u00e9k lek\u00e9r\u00e9se (2. verzi\u00f3) // a l\u00e9nyegi k\u00fcl\u00f6nbs\u00e9g a k\u00e9t oper\u00e1tor m\u0171k\u00f6d\u00e9s\u00e9ben let valami = \"foglalkozas\" ; console . log ( szemely . valami ); // a valami nev\u0171 property-hez tartoz\u00f3 \u00e9rt\u00e9k lek\u00e9r\u00e9se (nincs ilyen!) console . log ( szemely [ valami ]); // a foglalkozas nev\u0171 property-hez tartoz\u00f3 \u00e9rt\u00e9k lek\u00e9r\u00e9se A k\u00f3d kimenete B\u00e9la B\u00e9la undefined programoz\u00f3 Fontosabb m\u0171veletek objektumokon: Property el\u0151fordul\u00e1s\u00e1nak ellen\u0151rz\u00e9se Property-hez tartoz\u00f3 \u00e9rt\u00e9k m\u00f3dos\u00edt\u00e1sa \u00daj property-\u00e9rt\u00e9k p\u00e1r besz\u00far\u00e1sa Megl\u00e9v\u0151 property-\u00e9rt\u00e9k p\u00e1r t\u00f6rl\u00e9se 1 2 3 4 5 6 7 8 9 10 11 let szemely = { nev : \"B\u00e9la\" , kor : 20 , foglalkozas : \"programoz\u00f3\" }; if ( \"foglalkozas\" in szemely ) { // szerepel-a a foglalkozas property az objektumban console . log ( \"Ismerj\u00fck a foglalkoz\u00e1st.\" ); } szemely . nev = \"Sanyi\" ; // property-hez tartoz\u00f3 \u00e9rt\u00e9k m\u00f3dos\u00edt\u00e1sa szemely . szuletesiEv = 2000 ; // \u00faj property-\u00e9rt\u00e9k p\u00e1r besz\u00far\u00e1sa delete szemely . kor ; // megl\u00e9v\u0151 property-\u00e9rt\u00e9k p\u00e1r t\u00f6rl\u00e9se console . log ( szemely ); A k\u00f3d kimenete Ismerj\u00fck a foglalkoz\u00e1st. { nev: 'Sanyi', foglalkozas: 'programoz\u00f3', szuletesiEv: 2000 } Objektumok bej\u00e1r\u00e1sa: az Object.entries(obj) egy \"nagy\" t\u00f6mb\u00f6t ad vissza, amelynek minden eleme egy kisebb t\u00f6mb, amely az obj objektum egyik property-j\u00e9nek a nev\u00e9t \u00e9s az ahhoz tartoz\u00f3 \u00e9rt\u00e9ket t\u00e1rolja; ezen a \"nagy\" t\u00f6mb\u00f6n megy\u00fcnk v\u00e9gig egy for -ciklussal 1 2 3 4 5 6 7 8 9 10 11 let szemely = { nev : \"B\u00e9la\" , kor : 20 , foglalkozas : \"programoz\u00f3\" }; // Az Object.entries(szemely) tartalma a k\u00f6vetkez\u0151 t\u00f6mb: // [['nev', 'B\u00e9la'], ['kor', 20], ['foglalkozas', 'programoz\u00f3']] for ( let [ property , ertek ] of Object . entries ( szemely )) { // A bels\u0151 t\u00f6mb\u00f6k\u00f6n megy\u00fcnk v\u00e9gig, amelyek az egyes property-k nev\u00e9t \u00e9s \u00e9rt\u00e9k\u00e9t t\u00e1rolj\u00e1k // Ezeket sz\u00e9tszedj\u00fck: a property v\u00e1ltoz\u00f3ba ker\u00fcl a property neve, az ertek v\u00e1ltoz\u00f3ba pedig az \u00e9rt\u00e9ke console . log ( ` ${ property } \u00e9rt\u00e9ke: ${ ertek } ` ); } A k\u00f3d kimenete nev \u00e9rt\u00e9ke: B\u00e9la kor \u00e9rt\u00e9ke: 20 foglalkozas \u00e9rt\u00e9ke: programoz\u00f3 Egy\u00e9b adatszerkezetek \u00b6 Lek\u00e9pez\u00e9s (map) : kulcs-\u00e9rt\u00e9k p\u00e1rok t\u00e1rol\u00e1sa Halmaz (set) : az elemeket ism\u00e9tl\u0151d\u00e9s n\u00e9lk\u00fcl t\u00e1rolja, \u00e9s az elemek k\u00f6z\u00f6tt nincs sorrendis\u00e9g Objektumorient\u00e1lts\u00e1g \u00b6 Oszt\u00e1lyok, objektumok \u00b6 Oszt\u00e1ly: azonos tulajdons\u00e1ggal \u00e9s viselked\u00e9ssel rendelkez\u0151 objektumok \u00e1ltal\u00e1nos formai le\u00edr\u00e1sa (egy \"tervrajz\", ami alapj\u00e1n konkr\u00e9t objektumokat k\u00e9sz\u00edt\u00fcnk majd) L\u00e9trehoz\u00e1s: class kulcssz\u00f3val Az oszt\u00e1lyban adattagok \u00e9s met\u00f3dusok hozhat\u00f3k l\u00e9tre El\u00e9r\u00e9s\u00fck: . oper\u00e1torral A this kulcssz\u00f3val hivatkozhatunk mag\u00e1ra az objektumra - JavaScriptben a this -t mindig ki kell \u00edrni, ha egy adattagra vagy egy met\u00f3dusra hivatkozunk JavaScriptben az adattagokat a konstruktorban hozzuk l\u00e9tre (nem az oszt\u00e1ly t\u00f6rzs\u00e9nek elej\u00e9n) Konstruktor: az oszt\u00e1ly p\u00e9ld\u00e1nyos\u00edt\u00e1sakor (azaz egy objektum legy\u00e1rt\u00e1sakor) fut le L\u00e9trehoz\u00e1s: constructor() nev\u0171 met\u00f3dus defini\u00e1l\u00e1sa az oszt\u00e1lyon bel\u00fcl \u00c1ltal\u00e1ban az adattagok l\u00e9trehoz\u00e1s\u00e1ra \u00e9s inicializ\u00e1l\u00e1s\u00e1ra haszn\u00e1ljuk Objektumok: az oszt\u00e1lyokb\u00f3l val\u00f3 p\u00e9ld\u00e1nyos\u00edt\u00e1ssal hozhatjuk \u0151ket l\u00e9tre P\u00e9ld\u00e1nyos\u00edt\u00e1s szintaxisa: new OsztalyNeve(/* konstruktor param\u00e9terek... */) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Allat { // egy oszt\u00e1ly l\u00e9trehoz\u00e1sa constructor ( nev , kor ) { // konstruktor this . nev = nev ; // adattagok l\u00e9trehoz\u00e1sa \u00e9s inicializ\u00e1l\u00e1sa this . kor = kor ; } info () { // egy met\u00f3dus az oszt\u00e1lyon bel\u00fcl console . log ( ` ${ this . nev } egy ${ this . kor } \u00e9ves \u00e1llat.` ); } } let allat1 = new Allat ( \"Cs\u0151rike\" , 3 ); // oszt\u00e1ly p\u00e9ld\u00e1nyos\u00edt\u00e1sa (objektumok gy\u00e1rt\u00e1sa) let allat2 = new Allat ( \"Szilveszter\" , 5 ); allat1 . info (); // info() met\u00f3dus megh\u00edv\u00e1sa az adott objektumra allat2 . info (); A k\u00f3d kimenete Cs\u0151rike egy 3 \u00e9ves \u00e1llat. Szilveszter egy 5 \u00e9ves \u00e1llat. L\u00e1that\u00f3s\u00e1gok, getterek, setterek \u00b6 JavaScriptben nincsenek az adattagok l\u00e1that\u00e1s\u00e1t szab\u00e1lyoz\u00f3 m\u00f3dos\u00edt\u00f3szavak, alapb\u00f3l minden adattag \u00e9s met\u00f3dus publikus l\u00e1that\u00f3s\u00e1g\u00fa Konvenci\u00f3 alapj\u00e1n a nem publikus haszn\u00e1latra sz\u00e1nt adattagok neve el\u00e9 _ (alulvon\u00e1s) karakter \u00edrunk (de ett\u0151l m\u00e9g k\u00edv\u00fclr\u0151l ugyan\u00fagy el\u00e9rhet\u0151!) Az getterek \u00e9s setterek megval\u00f3s\u00edt\u00e1sa property-kkel t\u00f6rt\u00e9nik Getter l\u00e9trehoz\u00e1sa egy adattag \u00e9rt\u00e9k\u00e9nek lek\u00e9r\u00e9s\u00e9re: get property-vel Setter l\u00e9trehoz\u00e1sa egy adattag \u00e9rt\u00e9k\u00e9nek be\u00e1ll\u00edt\u00e1s\u00e1ra: set property-vel Olyan, mintha egy teljesen \u00faj adattag j\u00f6nne l\u00e9tre az objektumon bel\u00fcl Nagyon fontos, hogy a getter/setter neve \u00e9s az adattag neve mindig elt\u00e9r\u0151 legyen, k\u00fcl\u00f6nben v\u00e9gtelen rekurzi\u00f3ba futunk! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Allat { constructor ( nev , kor ) { this . nev = nev ; this . _kor = kor ; // nem publikus haszn\u00e1latra sz\u00e1nt adattag } get kor () { // getter return this . _kor ; } set kor ( ertek ) { // setter if ( ertek < 1 ) console . log ( \"HIBA: Pozit\u00edv sz\u00e1mot adj meg!\" ); else this . _kor = ertek ; } info () { console . log ( ` ${ this . nev } egy ${ this . kor } \u00e9ves \u00e1llat.` ); } } let allat1 = new Allat ( \"Garfield\" , 6 ); let allat2 = new Allat ( \"Ubul\" , 5 ); allat1 . kor = 8 ; // set property h\u00edv\u00e1sa allat2 . kor = - 1 ; console . log ( allat1 . kor ); // get property h\u00edv\u00e1s allat1 . info (); allat2 . info (); A k\u00f3d kimenete HIBA: Pozit\u00edv sz\u00e1mot adj meg! 8 Garfield egy 8 \u00e9ves \u00e1llat. Ubul egy 5 \u00e9ves \u00e1llat. \u00d6r\u00f6kl\u0151d\u00e9s \u00b6 Oszt\u00e1lyok k\u00f6z\u00f6tti kapcsolat, amely egy \u0151soszt\u00e1ly \u00e9s egy gyermekoszt\u00e1ly k\u00f6z\u00f6tt val\u00f3sul meg. A gyermekoszt\u00e1ly tulajdonk\u00e9ppen az \u0151soszt\u00e1lynak egy speci\u00e1lis v\u00e1ltozata lesz (pl. a Macska oszt\u00e1ly az Allat oszt\u00e1ly gyermeke, hiszen minden macska egyben \u00e1llat is). A gyermekoszt\u00e1ly meg\u00f6r\u00f6kli az \u0151soszt\u00e1ly \u00f6sszes adattagj\u00e1t \u00e9s met\u00f3dus\u00e1t A gyermekoszt\u00e1ly az \u00f6r\u00f6k\u00f6lteken k\u00edv\u00fcl \u00fajabb adattagokat \u00e9s met\u00f3dusokat is tartalmazhat A gyermekoszt\u00e1ly fel\u00fcldefini\u00e1lhatja egy \u00f6r\u00f6k\u00f6lt met\u00f3dus m\u0171k\u00f6d\u00e9s\u00e9t ( overriding ) \u00d6r\u00f6kl\u0151d\u00e9s JavaScriptben: Szintaxisa: class GyermekOsztaly extends OsOsztaly JavaScriptben csak egyszeres \u00f6r\u00f6kl\u0151d\u00e9s lehets\u00e9ges! Ez azt jelenti, hogy egy gyermekoszt\u00e1lynak nem lehet 1-n\u00e9l t\u00f6bb \u0151se A gyermekoszt\u00e1lyban a super kulcssz\u00f3val hivatkozhatunk az \u0151soszt\u00e1lyra 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Allat { // \u0151soszt\u00e1ly constructor ( nev , kor ) { this . nev = nev ; this . _kor = kor ; } get kor () { return this . _kor ; } set kor ( ertek ) { if ( ertek < 1 ) console . log ( \"HIBA: Pozit\u00edv sz\u00e1mot adj meg!\" ); else this . _kor = ertek ; } info () { console . log ( ` ${ this . nev } egy ${ this . kor } \u00e9ves \u00e1llat.` ); } eszik ( mit ) { console . log ( ` ${ this . nev } \u00e9ppen eszi ezt: ${ mit } .` ); } } class Macska extends Allat { // gyermekoszt\u00e1ly constructor ( nev , kor , fajta ) { super ( nev , kor ); // \u0151soszt\u00e1ly konstruktor\u00e1nak megh\u00edv\u00e1sa this . fajta = fajta ; } dorombol () { console . log ( \"PURR!\" ); } // overriding: \u0151soszt\u00e1lyb\u00f3l \u00f6r\u00f6k\u00f6lt met\u00f3dus m\u0171k\u00f6d\u00e9s\u00e9nek fel\u00fcl\u00edr\u00e1sa info () { console . log ( ` ${ this . nev } egy ${ this . fajta } macska.` ); } } let macska = new Macska ( \"Cirmi\" , 3 , \"perzsa\" ); macska . eszik ( \"tonhal\" ); macska . dorombol (); macska . info (); A k\u00f3d kimenete Cirmi \u00e9ppen eszi ezt: tonhal. PURR! Cirmi egy perzsa macska. T\u00edpusellen\u0151rz\u00e9s \u00b6 Egyszer\u0171bb t\u00edpusok (boolean, number, string, object, function) eset\u00e9n: typeof val === \"type\" (visszaadja, hogy a val \u00e9rt\u00e9k type t\u00edpus\u00fa-e) T\u00f6mb\u00f6k \u00e9s oszt\u00e1lyb\u00f3l p\u00e9ld\u00e1nyos\u00edtott objektumok eset\u00e9n: obj instanceof Osztaly (visszaadja, hogy obj az Osztaly p\u00e9ld\u00e1nya-e) A t\u00f6mb\u00f6k az Array be\u00e9p\u00edtett oszt\u00e1ly p\u00e9ld\u00e1nyai 1 2 3 4 5 6 7 8 9 10 11 12 console . log ( typeof 42 === \"number\" ); // true console . log ( typeof 42 === \"string\" ); // false let tomb = [ 10 , 20 , 30 , 40 , 50 ]; console . log ( tomb instanceof Array ); // true class Kutya { constructor ( nev , kor , fajta ) { /* ... */ } } let kutya = new Kutya ( \"Rex\" , 4 , \"n\u00e9metjuh\u00e1sz\" ); console . log ( kutya instanceof Kutya ); // true","title":"00. JavaScript gyorstalpal\u00f3"},{"location":"00_js_recap/#00-javascript-gyorstalpalo","text":"Mivel az Angular egy JavaScript keretrendszer, ez\u00e9rt fontos, hogy valamennyire tiszt\u00e1ban legy\u00fcnk a JavaScript nyelv szintaxis\u00e1val, alapvet\u0151 elemeivel. Ebben a fejezetben v\u00e1zlatosan \u00e1ttekintj\u00fck a JavaScripttel kapcsolatos fontosabb ismereteket. A fejezet csup\u00e1n kieg\u00e9sz\u00edt\u00e9sk\u00e9nt szolg\u00e1l a jegyzethez, \u00edgy azok, akik m\u00e1r rutinosan mozognak a JavaScript vil\u00e1g\u00e1ban, nyugodtan \u00e1tugorhatj\u00e1k ezt a r\u00e9szt.","title":"00. JavaScript gyorstalpal\u00f3"},{"location":"00_js_recap/#javascript-kod-irasa-es-futtatasa","text":"A JavaScript k\u00f3dot be\u00e1gyazhatjuk HTML dokumentumokba \u00e9s futtathatjuk azt b\u00f6ng\u00e9sz\u0151ben. Egy m\u00e1sik opci\u00f3 a Node.js futtat\u00f3k\u00f6rnyezet haszn\u00e1lata. Ekkor nem kell a JavaScript k\u00f3dunkhoz semmilyen \"HTML k\u00f6r\u00edt\u00e9st\" \u00edrnunk, hanem parancssorb\u00f3l tudjuk futtatni azt. T\u00f6lts\u00fck le innen a Node.js LTS (Long Term Support) verzi\u00f3j\u00e1t, majd telep\u00edts\u00fck azt! Az \u00e1ltalunk \u00edrt JavaScript k\u00f3dot ments\u00fck el egy .js kiterjeszt\u00e9s\u0171 f\u00e1jlba! A f\u00e1jlban l\u00e9v\u0151 k\u00f3dot a node fajlnev.js parancs kiad\u00e1s\u00e1val futtassuk parancssorb\u00f3l!","title":"JavaScript k\u00f3d \u00edr\u00e1sa \u00e9s futtat\u00e1sa"},{"location":"00_js_recap/#szintaxis-alapveto-nyelvi-elemek","text":"A JavaScript utas\u00edt\u00e1sok v\u00e9g\u00e9re nem k\u00f6telez\u0151 pontosvessz\u0151t tenni, viszont bizonyos esetekben a pontosvessz\u0151 elhagy\u00e1sa nem v\u00e1rt m\u0171k\u00f6d\u00e9st eredm\u00e9nyezhet. Emiatt c\u00e9lszer\u0171 a pontosvessz\u0151t mindig kitenni az utas\u00edt\u00e1sok v\u00e9g\u00e9re!","title":"Szintaxis, alapvet\u0151 nyelvi elemek"},{"location":"00_js_recap/#kommentek-megjegyzesek","text":"1 2 3 4 5 6 // ez egy egysoros komment /* ez egy t\u00f6bb soros komment */","title":"Kommentek (Megjegyz\u00e9sek)"},{"location":"00_js_recap/#kiiratasok","text":"console.log() : konzolra \u00edr\u00e1s (Node.js haszn\u00e1lata eset\u00e9n a parancssor-ablakra \u00edr, b\u00f6ng\u00e9sz\u0151s k\u00f6rnyezetben pedig a fejleszt\u0151i konzolra) alert() : felugr\u00f3 ablak (csak b\u00f6ng\u00e9sz\u0151s k\u00f6rnyezetben m\u0171k\u00f6dik) 1 2 console . log ( \"Hello World!\" ); console . log ( \"T\u00f6bb\" , \"param\u00e9ter\" , \"is\" , \"\u00e1tadhat\u00f3.\" ); A k\u00f3d kimenete Hello World! T\u00f6bb param\u00e9ter is \u00e1tadhat\u00f3.","title":"Ki\u00edrat\u00e1sok"},{"location":"00_js_recap/#alapveto-adattipusok","text":"Boolean: logikai adatt\u00edpus Lehets\u00e9ges \u00e9rt\u00e9kei: true (igaz) vagy false (hamis) Number: sz\u00e1m adatt\u00edpus Az eg\u00e9sz \u00e9s a lebeg\u0151pontos sz\u00e1mok t\u00edpusa (JavaScriptben nincs k\u00fcl\u00f6n int \u00e9s float) Minden sz\u00e1mot lebeg\u0151pontosk\u00e9nt \u00e1br\u00e1zol (sok esetben pazarl\u00f3) String: sz\u00f6veges adatt\u00edpus Sz\u00f6vegek megad\u00e1sa: aposztr\u00f3fok ( '...' ) vagy id\u00e9z\u0151jelek ( \"...\" ) k\u00f6z\u00f6tt Stringek \u00f6sszef\u0171z\u00e9se: + oper\u00e1torral Undefined: speci\u00e1lis adatt\u00edpus, egyetlen lehets\u00e9ges \u00e9rt\u00e9ke az undefined Az inicializ\u00e1l\u00e1s n\u00e9lk\u00fcli v\u00e1ltoz\u00f3k \u00e9rt\u00e9ke undefined A nem megadott f\u00fcggv\u00e9nyparam\u00e9terek \u00e9rt\u00e9ke undefined Egy objektum nem l\u00e9tez\u0151 adattagj\u00e1ra val\u00f3 hivatkoz\u00e1s eset\u00e9n undefined -ot kapunk","title":"Alapvet\u0151 adatt\u00edpusok"},{"location":"00_js_recap/#tipuskonverziok","text":"JavaScriptben a t\u00edpusok k\u00f6z\u00f6tti konverzi\u00f3 automatikusan t\u00f6rt\u00e9nik. K\u00e9t p\u00e9lda automatikus t\u00edpuskonverzi\u00f3ra: Ha a + oper\u00e1tor b\u00e1rmelyik operandusa string, akkor a m\u00e1sik operandust is stringre konvert\u00e1lja, \u00e9s \u00f6sszef\u0171zi a k\u00e9t stringet. Ha a * oper\u00e1tor valamelyik operandusa nem sz\u00e1m t\u00edpus\u00fa, akkor megpr\u00f3b\u00e1lja azt sz\u00e1mm\u00e1 konvert\u00e1lni. Ha az \u00e1talak\u00edt\u00e1s sikeres, akkor elv\u00e9gezz\u00fck a szorz\u00e1st, k\u00fcl\u00f6nben pedig NaN -t kapunk vissza (Not a Number). 1 2 3 \"2\" + 5 ; // \"2\" + \"5\" = \"25\" \"2\" * 5 ; // 2 * 5 = 10 \"sajt\" * 5 ; // NaN (Not a Number) Az automatikus t\u00edpuskonverzi\u00f3 mellett egy m\u00e1sik lehet\u0151s\u00e9g a typecasting (t\u00edpusk\u00e9nyszer\u00edt\u00e9s) : Boolean(expr) : az expr kifejez\u00e9st boolean t\u00edpus\u00fav\u00e1 alak\u00edtja Number(expr) : az expr kifejez\u00e9st number t\u00edpus\u00fav\u00e1 alak\u00edtja String(expr) : az expr kifejez\u00e9st string t\u00edpus\u00fav\u00e1 alak\u00edtja. A sz\u00e1mok k\u00f6z\u00f6tti konverzi\u00f3ra haszn\u00e1lhatjuk m\u00e9g a parseInt() (eg\u00e9sz \u00e9rt\u00e9kre konvert\u00e1l\u00e1s) \u00e9s a parseFloat() (lebeg\u0151pontos \u00e9rt\u00e9kre konvert\u00e1l\u00e1s) be\u00e9p\u00edtett f\u00fcggv\u00e9nyeket is. 1 2 3 4 5 Number ( \"3.14\" ); // 3.14 Number ( \"101 kiskutya\" ); // NaN (Not a Number) parseInt ( 3.14 ); // 3 String ( 42 ); // \"42\" Boolean ( 0 ); // false","title":"T\u00edpuskonverzi\u00f3k"},{"location":"00_js_recap/#valtozok","text":"JavaScriptben hagyom\u00e1nyos v\u00e1ltoz\u00f3 l\u00e9trehoz\u00e1sra \u00e1ltal\u00e1ban a let kulcssz\u00f3t haszn\u00e1ljuk. A const kulcssz\u00f3val konstans v\u00e1ltoz\u00f3kat is l\u00e9trehozhatunk, amelyek kezd\u0151\u00e9rt\u00e9ke nem m\u00f3dos\u00edthat\u00f3. Megjegyz\u00e9s A let \u00e9s const kulcsszavakat a 2015-\u00f6s ECMAScript6 (ES6) szabv\u00e1ny vezette be. Kor\u00e1bban a var kulcssz\u00f3t haszn\u00e1ltuk v\u00e1ltoz\u00f3k l\u00e9trehoz\u00e1s\u00e1ra, ami egy\u00e9bk\u00e9nt a mai napig jelen van a nyelvben. Mivel viszont a var -nak van mindenf\u00e9le ny\u0171gje, ez\u00e9rt \u00e9rdemes nem azt haszn\u00e1lni a v\u00e1ltoz\u00f3l\u00e9trehoz\u00e1sra! 1 2 3 4 5 6 let nev = \"B\u00e9la\" ; // v\u00e1ltoz\u00f3 l\u00e9trehoz\u00e1sa console . log ( \"Hello! A nevem\" , nev ); const eletErtelme = 42 ; // konstans v\u00e1ltoz\u00f3 l\u00e9trehoz\u00e1sa console . log ( \"Az \u00e9let \u00e9rtelme:\" , eletErtelme ); // eletErtelme = 10; // HIBA: konstans v\u00e1ltoz\u00f3 \u00e9rt\u00e9ke nem m\u00f3dos\u00edthat\u00f3! A k\u00f3d kimenete Hello! A nevem B\u00e9la Az \u00e9let \u00e9rtelme: 42","title":"V\u00e1ltoz\u00f3k"},{"location":"00_js_recap/#dinamikus-tipusossag","text":"Az el\u0151z\u0151 k\u00f3dban \u00e9szrevehett\u00fck, hogy (C-vel ellent\u00e9tben) a v\u00e1ltoz\u00f3k l\u00e9trehoz\u00e1sakor nem \u00edrjuk ki expliciten a v\u00e1ltoz\u00f3t\u00edpust. Ennek az az oka, hogy a JavaScript egy dinamikusan t\u00edpusos nyelv , ami azt jelenti, hogy a JavaScript \u00e9rtelmez\u0151 automatikusan \"ki tudja tal\u00e1lni\" a v\u00e1ltoz\u00f3k t\u00edpus\u00e1t a benn\u00fck t\u00e1rolt \u00e9rt\u00e9k alapj\u00e1n. A dinamikus t\u00edpusoss\u00e1g egyik \u00e9rdekes k\u00f6vetkezm\u00e9nye, hogy ugyanabban a v\u00e1ltoz\u00f3ban ak\u00e1r elt\u00e9r\u0151 t\u00edpus\u00fa adatokat is t\u00e1rolhatunk. Erre l\u00e1thatunk p\u00e9ld\u00e1t az al\u00e1bbi k\u00f3dban. 1 2 3 4 let val = 42 ; // val t\u00edpusa: number val = true ; // val t\u00edpusa: boolean val = undefined ; // val t\u00edpusa: undefined val = \"sajt\" ; // val t\u00edpusa: string","title":"Dinamikus t\u00edpusoss\u00e1g"},{"location":"00_js_recap/#fontosabb-operatorok","text":"Aritmetikai oper\u00e1torok: + (\u00f6sszead\u00e1s), - (kivon\u00e1s), * (szorz\u00e1s), / (val\u00f3s oszt\u00e1s), % (marad\u00e9kos oszt\u00e1s), ** (hatv\u00e1nyoz\u00e1s) Hozz\u00e1rendel\u0151 oper\u00e1torok: = , += , -= , *= , /= (ugyan\u00fagy m\u0171k\u00f6dnek, mint C-ben) Inkrement\u00e1l\u00f3, dekrement\u00e1l\u00f3 oper\u00e1torok: ++ , -- (ugyan\u00fagy m\u0171k\u00f6dnek, mint C-ben) \u00d6sszehasonl\u00edt\u00f3 oper\u00e1torok: == (azonos \u00e9rt\u00e9k), === (azonos \u00e9rt\u00e9k \u00e9s t\u00edpus), != (elt\u00e9r\u0151 \u00e9rt\u00e9k), !== (elt\u00e9r\u0151 \u00e9rt\u00e9k vagy t\u00edpus), < (kisebb), <= (kisebb vagy egyenl\u0151), > (nagyobb), >= (nagyobb vagy egyenl\u0151) Logikai oper\u00e1torok: && (logikai \u00c9S), || (logikai VAGY), ! (logikai NEM) Szeml\u00e9ltess\u00fck egy p\u00e9ld\u00e1n a == \u00e9s === oper\u00e1torok k\u00f6z\u00f6tti m\u0171k\u00f6d\u00e9sbeli k\u00fcl\u00f6nbs\u00e9get! Hasonl\u00edtsunk \u00f6ssze k\u00e9t kifejez\u00e9st, amelyre a k\u00e9t oper\u00e1tor elt\u00e9r\u0151 \u00e9rt\u00e9ket ad vissza! P\u00e9ld\u00e1ul: 1 2 console . log ( 0 == false ); // true console . log ( 0 === false ); // false Mi is t\u00f6rt\u00e9nik itt? Mivel egy sz\u00e1mot hasonl\u00edtunk \u00f6ssze egy logikai \u00e9rt\u00e9kkel, ez\u00e9rt a JavaScript automatikus t\u00edpuskonverzi\u00f3t v\u00e9gez. A t\u00edpuskonverzi\u00f3t k\u00f6vet\u0151en a k\u00e9t kifejez\u00e9s \u00e9rt\u00e9ke megegyezik (hiszen m\u00e1r C-b\u0151l tudjuk, hogy a 0 sz\u00e1m\u00e9rt\u00e9k a false logikai \u00e9rt\u00e9knek felel meg), ez\u00e9rt a == oper\u00e1tor igazat ad vissza. Viszont mivel a kifejez\u00e9sek t\u00edpusa elt\u00e9r (a 0 number, m\u00edg a false boolean t\u00edpus\u00fa), ez\u00e9rt a === oper\u00e1tor hamisat ad vissza. JavaScriptben a / oper\u00e1tor alapb\u00f3l val\u00f3s oszt\u00e1st v\u00e9gez. Hogyan val\u00f3s\u00edtan\u00e1nk meg az eg\u00e9szoszt\u00e1st? Mivel l\u00e9nyeg\u00e9ben az oszt\u00e1s ut\u00e1n kapott tizedes t\u00f6rt eg\u00e9szr\u00e9sz\u00e9re vagyunk k\u00edv\u00e1ncsiak, ez\u00e9rt csak a val\u00f3s oszt\u00e1ssal kapott \u00e9rt\u00e9ket kell lefel\u00e9 kerek\u00edten\u00fcnk. A lefel\u00e9 kerek\u00edt\u00e9sre a Math.floor() f\u00fcggv\u00e9nyt haszn\u00e1ljuk. 1 2 const egeszResz = Math . floor ( 5 / 2 ); console . log ( egeszResz ); // 2 A Math objektum egy\u00e9bk\u00e9nt rengeteg hasznos matematikai f\u00fcggv\u00e9nyt \u00e9s konstanst biztos\u00edt a sz\u00e1munkra. Err\u0151l b\u0151vebben ezen a linken olvashatunk.","title":"Fontosabb oper\u00e1torok"},{"location":"00_js_recap/#vezerlesi-szerkezetek","text":"A szelekci\u00f3s vez\u00e9rl\u00e9s megval\u00f3s\u00edt\u00e1s\u00e1ra az if , else if , else \u00e9s switch utas\u00edt\u00e1sokat haszn\u00e1lhatjuk. Ezek ugyan\u00fagy m\u0171k\u00f6dnek, mint C-ben. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 let szam = 5 ; if ( szam < 0 ) { console . log ( \"A sz\u00e1m negat\u00edv.\" ); } else if ( szam === 0 ) { console . log ( \"A sz\u00e1m nulla.\" ); } else { console . log ( \"Pozit\u00edv.\" ); } switch ( szam ) { case 1 : console . log ( \"El\u00e9gtelen.\" ); break ; case 2 : console . log ( \"El\u00e9gs\u00e9ges.\" ); break ; case 3 : console . log ( \"K\u00f6zepes.\" ); break ; case 4 : console . log ( \"J\u00f3.\" ); break ; case 5 : console . log ( \"Jeles.\" ); break ; default : console . log ( \"\u00c9rv\u00e9nytelen \u00e9rt\u00e9k!\" ); } A k\u00f3d kimenete Pozit\u00edv. Jeles. Az egyetlen if -b\u0151l \u00e9s az ahhoz tartoz\u00f3 else -b\u0151l \u00e1ll\u00f3 felt\u00e9telek megad\u00e1s\u00e1ra a C-b\u0151l ismer\u0151s ternary oper\u00e1tor is haszn\u00e1lhat\u00f3. Ennek a szintaxisa a szok\u00e1sos: <felt\u00e9tel> ? <m\u0171velet, ha igaz> : <m\u0171velet, ha hamis> . 1 2 let eletkor = 12 ; console . log ( eletkor >= 18 ? \"Nagykor\u00fa vagy.\" : \"M\u00e9g kiskor\u00fa vagy.\" ); A k\u00f3d kimenete M\u00e9g kiskor\u00fa vagy. Az ism\u00e9tl\u00e9ses vez\u00e9rl\u00e9s (ciklusok) megval\u00f3s\u00edt\u00e1s\u00e1ra a while , do... while \u00e9s for utas\u00edt\u00e1sokat haszn\u00e1lhatjuk. Ezek szint\u00e9n ugyan\u00fagy m\u0171k\u00f6dnek, mint C-ben. Gyakorl\u00e1sk\u00e9ppen \u00edrassuk ki az eg\u00e9sz sz\u00e1mokat 1-t\u0151l 10-ig mindh\u00e1rom ciklussal! 1 2 3 4 5 6 let i = 1 ; while ( i <= 10 ) { // while-ciklus console . log ( i ); i ++ ; } 1 2 3 4 5 6 let i = 1 ; do { // do...while-ciklus console . log ( i ); i ++ ; } while ( i <= 10 ); 1 2 3 for ( let i = 1 ; i <= 10 ; i ++ ) { // for-ciklus console . log ( i ); }","title":"Vez\u00e9rl\u00e9si szerkezetek"},{"location":"00_js_recap/#fuggvenyek","text":"A f\u00fcggv\u00e9nydefin\u00edci\u00f3 \u00e1ltal\u00e1nos szintaxisa JavaScriptben: 1 2 3 4 function fuggvenyNeve ( param1 , param2 , ...) { // utas\u00edt\u00e1sok... return visszateresiErtek ; // elhagyhat\u00f3! } A f\u00fcggv\u00e9nyh\u00edv\u00e1s \u00e1ltal\u00e1nos szintaxisa JavaScriptben: 1 fuggvenyNeve ( param1 , param2 , ...);","title":"F\u00fcggv\u00e9nyek"},{"location":"00_js_recap/#default-parameterek","text":"JavaScriptben (Jav\u00e1val ellent\u00e9tben) nem m\u0171k\u00f6dik a f\u00fcggv\u00e9ny overloading (m\u00e9g elt\u00e9r\u0151 param\u00e9terez\u00e9s eset\u00e9n sem). Ha t\u00f6bb azonos nev\u0171 f\u00fcggv\u00e9ny\u00fcnk van, akkor mindig a k\u00f3dban legk\u00e9s\u0151bb defini\u00e1lt f\u00fcggv\u00e9ny lesz h\u00edvhat\u00f3. 1 2 3 4 5 6 7 8 9 10 function hello () { console . log ( \"Szia!\" ); } function hello ( nev ) { // ez a legutolj\u00e1ra l\u00e9trehozott hello() f\u00fcggv\u00e9ny, ez lesz h\u00edvhat\u00f3! console . log ( \"Szia \" + nev + \"!\" ); } hello (); // a nem megadott nev param\u00e9ter \u00e9rt\u00e9ke undefined lesz a f\u00fcggv\u00e9nyh\u00edv\u00e1s sor\u00e1n hello ( \"Tam\u00e1s\" ); A k\u00f3d kimenete Szia undefined! Szia Tam\u00e1s! A default f\u00fcggv\u00e9nyparam\u00e9terek viszont lehet\u0151s\u00e9get biztos\u00edtanak arra, hogy egy f\u00fcggv\u00e9nyt ak\u00e1r elt\u00e9r\u0151 param\u00e9terez\u00e9ssel is haszn\u00e1lhassunk. Ezeknek a l\u00e9nyege, hogy a f\u00fcggv\u00e9ny bizonyos param\u00e9tereinek alap\u00e9rtelmezett \u00e9rt\u00e9ket adunk a f\u00fcggv\u00e9nydefin\u00edci\u00f3kor. Ha a f\u00fcggv\u00e9nyh\u00edv\u00e1skor egy param\u00e9ter \u00e9rt\u00e9k\u00e9t nem adjuk meg, akkor az az alap\u00e9rtelmezett \u00e9rt\u00e9ket veszi fel. 1 2 3 4 5 6 function hello ( nev = \"Senki\" ) { console . log ( \"Szia \" + nev + \"!\" ); } hello (); // mivel nem adtuk \u00e1t a param\u00e9ter \u00e9rt\u00e9k\u00e9t, ez\u00e9rt az a default \u00e9rt\u00e9ket veszi fel hello ( \"Tam\u00e1s\" ); // itt a param\u00e9ter \u00e9rt\u00e9ke term\u00e9szetesen az \u00e1tadott \u00e9rt\u00e9k lesz Kimenet Szia Senki! Szia Tam\u00e1s! Ha egy f\u00fcggv\u00e9ny nem minden param\u00e9ter\u00e9nek adunk default \u00e9rt\u00e9ket, akkor a default \u00e9rt\u00e9kkel rendelkez\u0151 param\u00e9terek mindig a param\u00e9terlista jobb oldal\u00e1n kell, hogy szerepljenek (m\u00e1sk\u00e9pp mondva: mindig az utols\u00f3 n\u00e9h\u00e1ny param\u00e9ternek adunk default \u00e9rt\u00e9ket)! 1 2 3 4 5 6 7 function info ( nev , eletkor = 20 , foglalkozas = \"programoz\u00f3\" ) { console . log ( nev + \" egy \" + eletkor + \" \u00e9ves \" + foglalkozas + \".\" ); } info ( \"Sanyi\" ); info ( \"J\u00f3zsi\" , 50 ); info ( \"B\u00e9la\" , 40 , \"asztronauta\" ); A k\u00f3d kimenete Sanyi egy 20 \u00e9ves programoz\u00f3. J\u00f3zsi egy 50 \u00e9ves programoz\u00f3. B\u00e9la egy 40 \u00e9ves asztronauta.","title":"Default param\u00e9terek"},{"location":"00_js_recap/#callback-fuggvenyek","text":"JavaScriptben el\u0151fordul, hogy egy f\u00fcggv\u00e9nyt egy m\u00e1sik f\u00fcggv\u00e9ny param\u00e9terek\u00e9nt haszn\u00e1lunk fel. Az ilyen f\u00fcggv\u00e9nyeket nevezz\u00fck callback f\u00fcggv\u00e9nynek . A callback f\u00fcggv\u00e9nyt term\u00e9szetesen meg is h\u00edvhatjuk abban a f\u00fcggv\u00e9nyben, amely param\u00e9ter\u00fcl kapja azt. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Ez lesz majd a callback f\u00fcggv\u00e9ny\u00fcnk, amit megh\u00edvunk egy m\u00e1sik f\u00fcggv\u00e9nyben function feldolgoz () { console . log ( \"Meg\u00e9rkezett az adat! Dolgozzuk fel...\" ); } // Ez a f\u00fcggv\u00e9ny egy 2 m\u00e1sodpercig tart\u00f3 adatlek\u00e9rdez\u00e9st szimul\u00e1l (p\u00e9ld\u00e1ul egy adatb\u00e1zisb\u00f3l) // Amikor az adat meg\u00e9rkezik (letelik a 2 m\u00e1sodperc), megh\u00edvjuk a param\u00e9terben kapott callback f\u00fcggv\u00e9nyt function adatLekerdezes ( callback ) { setTimeout ( callback , 2000 ); // 2 m\u00e1sodperces timeout, majd callback f\u00fcggv\u00e9ny megh\u00edv\u00e1sa console . log ( \"Ajaj, ez hamarabb lefut, mint ahogy meg\u00e9rkezne az adat!\" ); } // F\u00fcggv\u00e9nyh\u00edv\u00e1s, ahol a callback f\u00fcggv\u00e9ny a feldolgoz() f\u00fcggv\u00e9ny lesz adatLekerdezes ( feldolgoz ); Kimenet Ajaj, ez hamarabb lefut, mint ahogy meg\u00e9rkezne az adat! Meg\u00e9rkezett az adat! Dolgozzuk fel...","title":"Callback f\u00fcggv\u00e9nyek"},{"location":"00_js_recap/#anonim-fuggvenyek-es-arrow-function-ok","text":"Az anonim f\u00fcggv\u00e9nyek n\u00e9v n\u00e9lk\u00fcli f\u00fcggv\u00e9nyek, amelyeket kifejez\u00e9sk\u00e9nt defini\u00e1lunk. Ezeket a f\u00fcggv\u00e9ny kifejez\u00e9seket v\u00e1ltoz\u00f3kban is elt\u00e1rolhatjuk, majd amikor meg szeretn\u00e9nk h\u00edvni \u0151ket, akkor a v\u00e1ltoz\u00f3 nev\u00e9vel hivatkozhatunk r\u00e1juk. 1 2 let osszead = function ( a , b ) { return a + b ; } // anonim f\u00fcggv\u00e9ny console . log ( osszead ( 10 , 20 )); // f\u00fcggv\u00e9nyh\u00edv\u00e1s A k\u00f3d kimenete 30 Az ECMAScript6 (ES6) szabv\u00e1nyban bevezett\u00e9k az \u00fagynevezett arrow function -\u00f6ket az anonim f\u00fcggv\u00e9nyek t\u00f6m\u00f6rebb megad\u00e1s\u00e1ra. Szintaxisuk a k\u00f6vetkez\u0151: 1 ( param1 , param2 , ...) => { /* f\u00fcggv\u00e9nyt\u00f6rzs... */ } Ha a f\u00fcggv\u00e9nyt\u00f6rzs egyetlen utas\u00edt\u00e1sb\u00f3l \u00e1ll, akkor a { \u00e9s } szabadon elhagyhat\u00f3. Ha a f\u00fcggv\u00e9nyt\u00f6rzs egyetlen return utas\u00edt\u00e1sb\u00f3l \u00e1ll, akkor a return kulcssz\u00f3 elhagyhat\u00f3. Ha a f\u00fcggv\u00e9ny\u00fcnk nem v\u00e1r param\u00e9tert, akkor a => el\u0151tti z\u00e1r\u00f3jelp\u00e1rt \u00fcresen hagyjuk. Ha a f\u00fcggv\u00e9ny\u00fcnk egyetlen param\u00e9tert v\u00e1r, akkor a => el\u0151tti z\u00e1r\u00f3jelek elhagyhat\u00f3k. 1 2 3 4 5 6 7 8 9 10 11 12 // 0 param\u00e9tert v\u00e1r\u00f3 arrow function let koszontes = () => { console . log ( \"Halih\u00f3!\" ); console . log ( \"Ez egy p\u00e9ldaprogram arrow function-\u00f6kre.\" ); } // 1 param\u00e9tert v\u00e1r\u00f3 arrow function let uvolt = szoveg => console . log ( szoveg . toUpperCase () + \"!!!\" ); // 2 param\u00e9tert v\u00e1r\u00f3 arrow function let hatvanyoz = ( alap , kitevo ) => alap ** kitevo ; // ugyanaz, mint (alap, kitevo) => { return alap ** kitevo; } koszontes (); uvolt ( \"aaaaa\" ); console . log ( hatvanyoz ( 2 , 10 )); A k\u00f3d kimenete Halih\u00f3! Ez egy p\u00e9ldaprogram arrow function-\u00f6kre. AAAAA!!! 1024","title":"Anonim f\u00fcggv\u00e9nyek \u00e9s arrow function-\u00f6k"},{"location":"00_js_recap/#stringek-szovegek","text":"Megad\u00e1suk: \u00e1ltal\u00e1ban aposztr\u00f3fok ( '...' ) vagy id\u00e9z\u0151jelek ( \"...\" ) k\u00f6z\u00f6tt t\u00f6bb soros sz\u00f6vegeket backtick-ek k\u00f6z\u00f6tt adhatunk meg (magyar billenty\u0171zeten az AltGr + 7 billenty\u0171kombin\u00e1ci\u00f3val \u00edrhatunk backtick-et) 1 2 3 4 5 6 7 let egysoros1 = 'Ez egy sz\u00f6veg' ; let egysoros2 = \"Ez egy m\u00e1sik sz\u00f6veg\" ; let tobbsoros = `Never gonna give you up Never gonna let you down Never gonna run around And desert you` ; Stringek \u00f6sszef\u0171z\u00e9se: + oper\u00e1torral String hossz\u00e1nak lek\u00e9rdez\u00e9se: length property-vel 1 2 3 let szoveg = \"kecske\" + \"sajt\" ; // stringek \u00f6sszef\u0171z\u00e9se console . log ( szoveg ); console . log ( szoveg . length ); // string hossz\u00e1nak lek\u00e9rdez\u00e9se A k\u00f3d kimenete kecskesajt 10 Karakterek indexel\u00e9se: [] oper\u00e1torral, 0-t\u00f3l kezd\u0151d\u0151en JavaScriptben a string egy immutable adatt\u00edpus , azaz a sz\u00f6vegek a l\u00e9trehoz\u00e1s ut\u00e1n nem v\u00e1ltoztathat\u00f3k meg (teh\u00e1t pl. nem lehet egy string egy adott karakter\u00e9t m\u00f3dos\u00edtani) 1 2 3 4 5 6 let szoveg = \"kecskesajt\" ; console . log ( \"Az els\u0151 karakter: \" + szoveg [ 0 ]); console . log ( \"Az utols\u00f3 karakter: \" + szoveg [ szoveg . length - 1 ]); szoveg [ 0 ] = 'F' ; // ennek JavaScriptben nincs hat\u00e1sa (minden string immutable!) console . log ( szoveg ); A k\u00f3d kimenete Az els\u0151 karakter: k Az utols\u00f3 karakter: t kecskesajt N\u00e9h\u00e1ny stringkezel\u0151 f\u00fcggv\u00e9ny (teljes lista itt ): s.toLowerCase() : csupa kisbet\u0171ss\u00e9 alak\u00edtja az s stringet s.toUpperCase() : csupa nagybet\u0171ss\u00e9 alak\u00edtja az s stringet s.startsWith(t) : igazat ad vissza, ha az s string a t r\u00e9szsz\u00f6veggel kezd\u0151dik s.endsWith(t) : igazat ad vissza, ha az s string a t r\u00e9szsz\u00f6vegre v\u00e9gz\u0151dik s.trim() : elt\u00e1vol\u00edtja a whitespace karaktereket az s string elej\u00e9r\u0151l \u00e9s v\u00e9g\u00e9r\u0151l s.substring(start, end) : visszaad az s stringb\u0151l egy r\u00e9szstringet, a start index\u0171 karaktert\u0151l kezdve az end index\u0171 karakterig s.indexOf(t) : visszaadja a t r\u00e9szstring legels\u0151 el\u0151fordul\u00e1s\u00e1nak kezd\u0151index\u00e9t az s stringen bel\u00fcl ( -1 -et ad vissza, ha t nem szerepel az s stringben) s.split(sep) : feldarabolja az s stringet sep karakterek ment\u00e9n (egy t\u00f6mb\u00f6t ad vissza) 1 2 3 4 5 6 7 8 9 10 11 12 let szoveg = \" Ez egy p\u00e9ldasz\u00f6veg, amely t\u00f6bb sz\u00f3b\u00f3l \u00e1ll \" ; szoveg = szoveg . trim (); // whitespace karakterek elt\u00e1vol\u00edt\u00e1sa a sz\u00f6veg elej\u00e9r\u0151l \u00e9s v\u00e9g\u00e9r\u0151l console . log ( szoveg . toUpperCase ()); // nagybet\u0171s\u00edt\u00e9s console . log ( szoveg . endsWith ( \"\u00e1ll\" )); // az \"\u00e1ll\" stringre v\u00e9gz\u0151dik-e a sz\u00f6veg console . log ( szoveg . substring ( 12 , 18 )); // karakterek lek\u00e9r\u00e9se a 12.-t\u0151l a 18. indexig if ( szoveg . indexOf ( \"p\u00e9lda\" ) >= 0 ) // r\u00e9szstring el\u0151fordul\u00e1s\u00e1nak vizsg\u00e1lata console . log ( \"A sz\u00f6vegben szerepel a 'p\u00e9lda' r\u00e9szstring.\" ); let szavak = szoveg . split ( \" \" ); // sz\u00f6veg feldarabol\u00e1sa sz\u00f3k\u00f6z\u00f6k ment\u00e9n console . log ( szavak ); A k\u00f3d kimenete EZ EGY P\u00c9LDASZ\u00d6VEG, AMELY T\u00d6BB SZ\u00d3B\u00d3L \u00c1LL true sz\u00f6veg A sz\u00f6vegben szerepel a 'p\u00e9lda' r\u00e9szstring. [ 'Ez', 'egy', 'p\u00e9ldasz\u00f6veg,', 'amely', 't\u00f6bb', 'sz\u00f3b\u00f3l', '\u00e1ll' ]","title":"Stringek (Sz\u00f6vegek)"},{"location":"00_js_recap/#template-stringek","text":"Ha egy strinben be szeretn\u00e9nk helyettes\u00edteni k\u00fcl\u00f6nf\u00e9le kifejez\u00e9sek \u00e9rt\u00e9k\u00e9t, akkor hagyom\u00e1nyos string\u00f6sszef\u0171z\u00e9sek helyett haszn\u00e1lhatjuk az ES6 szabv\u00e1nyban bevezetett template stringeket . A template stringeket backtick-ek k\u00f6z\u00e9 \u00edrjuk, a behelyettes\u00edtend\u0151 \u00e9rt\u00e9keket ${ } seg\u00edts\u00e9g\u00e9vel adjuk meg a template stringen bel\u00fcl. 1 2 3 4 5 6 7 let nev = \"B\u00e9la\" , eletkor = 25 , foglalkozas = \"programoz\u00f3\" ; // 1. megold\u00e1s: hagyom\u00e1nyos string\u00f6sszef\u0171z\u00e9s (nem a legk\u00e9nyelmesebb...) console . log ( nev + \" egy \" + eletkor + \" \u00e9ves \" + foglalkozas + \".\" ); // 2. megold\u00e1s: template stringek haszn\u00e1lata (eleg\u00e1ns \u00e9s k\u00e9nyelmes) console . log ( ` ${ nev } egy ${ eletkor } \u00e9ves ${ foglalkozas } .` ); A k\u00f3d kimenete B\u00e9la egy 25 \u00e9ves programoz\u00f3. B\u00e9la egy 25 \u00e9ves programoz\u00f3.","title":"Template stringek"},{"location":"00_js_recap/#fontosabb-adatszerkezetek","text":"","title":"Fontosabb adatszerkezetek"},{"location":"00_js_recap/#tombok","text":"Tetsz\u0151leges mennyis\u00e9g\u0171, nem felt\u00e9tlen azonos t\u00edpus\u00fa adat t\u00e1rol\u00e1s\u00e1ra alkalmas L\u00e9trehoz\u00e1s: 1 2 3 let t1 = []; // \u00fcres t\u00f6mb let t2 = [ 10 , 20 , 30 , 40 ]; let t3 = [ \"alma\" , \"k\u00f6rte\" , \"szilva\" , \"barack\" ]; T\u00f6mb hossz\u00e1nak lek\u00e9rdez\u00e9se: length property-vel T\u00f6mbelemek indexel\u00e9se: [] oper\u00e1torral, 0-t\u00f3l kezd\u0151d\u0151en A stringekkel ellent\u00e9tben a t\u00f6mb egy mutable adatt\u00edpus, \u00edgy lehet\u0151s\u00e9g\u00fcnk van arra, hogy egy adott index\u0171 t\u00f6mbelem \u00e9rt\u00e9k\u00e9t m\u00f3dos\u00edtsuk 1 2 3 4 5 6 7 let gyumolcsok = [ \"alma\" , \"k\u00f6rte\" , \"szilva\" , \"barack\" ]; console . log ( ` ${ gyumolcsok . length } darab gy\u00fcm\u00f6lcs\u00fcnk van.` ); console . log ( `Az els\u0151 gy\u00fcm\u00f6lcs: ${ gyumolcsok [ 0 ] } ` ); console . log ( `Az utols\u00f3 gy\u00fcm\u00f6lcs: ${ gyumolcsok [ gyumolcsok . length - 1 ] } ` ); gyumolcsok [ 1 ] = \"ban\u00e1n\" ; // ez \u00edgy OK (a t\u00f6mb egy mutable adatt\u00edpus) console . log ( gyumolcsok ); A k\u00f3d kimenete 4 darab gy\u00fcm\u00f6lcs\u00fcnk van. Az els\u0151 gy\u00fcm\u00f6lcs: alma Az utols\u00f3 gy\u00fcm\u00f6lcs: barack [ 'alma', 'ban\u00e1n', 'szilva', 'barack' ] T\u00f6mb\u00f6k bej\u00e1r\u00e1sa: for -ciklussal Hagyom\u00e1nyos, index alap\u00fa for -ciklus vagy Listaszer\u0171 bej\u00e1r\u00e1s ( for - of szintaxis) 1 2 3 4 5 6 7 8 9 10 11 12 13 let gyumolcsok = [ \"alma\" , \"k\u00f6rte\" , \"szilva\" , \"barack\" ]; // hagyom\u00e1nyos, index alap\u00fa for-ciklus (ezt m\u00e1r C-b\u0151l is ismerj\u00fck) for ( let i = 0 ; i < gyumolcsok . length ; i ++ ) { console . log ( gyumolcsok [ i ]); } console . log ( \"------------------------------------\" ); // listaszer\u0171 for-ciklus: a gyumi v\u00e1ltoz\u00f3 rendre felveszi a t\u00f6mbelemek \u00e9rt\u00e9k\u00e9t for ( let gyumi of gyumolcsok ) { console . log ( gyumi ); } N\u00e9h\u00e1ny t\u00f6mbkezel\u0151 f\u00fcggv\u00e9ny (teljes lista itt ): t.pop() : t\u00f6rli az utols\u00f3 elemet a t t\u00f6mbb\u0151l t.push(a, b, ...) : besz\u00farja az a , b , ... elemeket a t t\u00f6mb v\u00e9g\u00e9re t.shift() : t\u00f6rli a legels\u0151 elemet a t t\u00f6mbb\u0151l t.unshift(a, b, ...) : besz\u00farja az a , b , ... elemeket a t t\u00f6mb elej\u00e9re t.sort() : rendezi a t t\u00f6mb elemeit (alapb\u00f3l stringekk\u00e9nt kezeli az elemeket!) t.indexOf(e) : visszaadja az e elem legels\u0151 el\u0151fordul\u00e1s\u00e1nak kezd\u0151index\u00e9t a t t\u00f6mb\u00f6n bel\u00fcl ( -1 -et ad vissza, ha e nem szerepel a t t\u00f6mbben) t.splice(i, count, a, b, ...) : elemek besz\u00far\u00e1sa vagy elemek t\u00f6rl\u00e9se Ha az a , b , ... \u00e9rt\u00e9k\u00e9t nem adjuk meg, akkor a kit\u00f6r\u00f6l a t t\u00f6mb i . index\u00e9t\u0151l kezdve count darab elemet Ha az a , b , ... \u00e9rt\u00e9keket megadjuk, akkor besz\u00farja ezeket a t t\u00f6mbbe, az i . indext\u0151l kezdve; ekkor a count \u00e9rt\u00e9k\u00e9t (a t\u00f6rlend\u0151 elemek sz\u00e1m\u00e1t) 0-ra \u00e1ll\u00edtjuk t.slice(start, end) : visszaadja a t t\u00f6mb start \u00e9s end-1 indexei k\u00f6z\u00f6tti elemeit egy t\u00f6mbben (az end param\u00e9ter elhagyhat\u00f3, ekkor a start -t\u00f3l kezdve az \u00f6sszes \"h\u00e1tral\u00e9v\u0151\" t\u00f6mbelemet kapjuk vissza) t.join(sep) : egy stringg\u00e9 egyes\u00edti a t t\u00f6mb\u00f6t, amiben a t\u00f6mbelemek sep karakterek ment\u00e9n lesznek elv\u00e1lasztva 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 let gyumolcsok = [ \"alma\" , \"k\u00f6rte\" , \"szilva\" , \"barack\" ]; gyumolcsok . pop (); // t\u00f6rl\u00e9s a v\u00e9g\u00e9r\u0151l gyumolcsok . push ( \"ban\u00e1n\" , \"citrom\" ); // besz\u00far\u00e1s a v\u00e9g\u00e9re gyumolcsok . shift (); // t\u00f6rl\u00e9s az elej\u00e9r\u0151l gyumolcsok . unshift ( \"dinnye\" ); // besz\u00far\u00e1s az elej\u00e9re console . log ( gyumolcsok ); gyumolcsok . splice ( 2 , 1 ); // 2. indexen l\u00e9v\u0151 t\u00f6mbelem t\u00f6rl\u00e9se console . log ( gyumolcsok ); console . log ( gyumolcsok . slice ( 1 , 3 )); // t\u00f6mbelemek lek\u00e9r\u00e9se az 1.-t\u0151l a 2. indexig if ( gyumolcsok . indexOf ( \"citrom\" ) >= 0 ) // t\u00f6mbelem el\u0151fordul\u00e1s\u00e1nak vizsg\u00e1lata console . log ( \"Van citrom a t\u00f6mbben!\" ); let gyumolcsSzoveg = gyumolcsok . join ( \", \" ); // t\u00f6mbelemek egyes\u00edt\u00e9se sz\u00f6vegg\u00e9 console . log ( `A gy\u00fcm\u00f6lcseink: ${ gyumolcsSzoveg } .` ); A k\u00f3d kimenete [ 'dinnye', 'k\u00f6rte', 'szilva', 'ban\u00e1n', 'citrom' ] [ 'dinnye', 'k\u00f6rte', 'ban\u00e1n', 'citrom' ] [ 'k\u00f6rte', 'ban\u00e1n' ] Van citrom a t\u00f6mbben! A gy\u00fcm\u00f6lcseink: dinnye, k\u00f6rte, ban\u00e1n, citrom. K\u00e9t tov\u00e1bbi hasznos t\u00f6mbkezel\u0151 f\u00fcggv\u00e9ny: map() \u00e9s filter() A map() egy callback f\u00fcggv\u00e9nyt v\u00e1r param\u00e9terk\u00e9nt, amelyet a t\u00f6mb minden elem\u00e9re v\u00e9grehajt. A callback f\u00fcggv\u00e9ny v\u00e9grehajt\u00e1sa ut\u00e1ni eredm\u00e9nyeket egy \u00faj t\u00f6mbben kapjuk vissza. P\u00e9lda: Adott egy sz\u00e1mokat tartalmaz\u00f3 t\u00f6mb. K\u00e9sz\u00edts\u00fcnk egy \u00faj t\u00f6mb\u00f6t, ami tartalmazza az eredeti t\u00f6mbben szerepl\u0151 sz\u00e1mok n\u00e9gyzet\u00e9t. 1 2 3 4 5 6 7 8 let szamok = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]; // A callback f\u00fcggv\u00e9ny megad\u00e1s\u00e1ra ebben a k\u00f3dban az arrow function-\u00f6s szintaxist haszn\u00e1ltuk // A callback f\u00fcggv\u00e9nynek egyetlen param\u00e9tere van (szam), amely mindig az aktu\u00e1lis t\u00f6mbelemet jelk\u00e9pezi // Vessz\u00fck a szamok t\u00f6mb minden elem\u00e9nek a n\u00e9gyzet\u00e9t \u00e9s bepakolgatjuk ezeket egy negyzetszamok nev\u0171 t\u00f6mbbe let negyzetszamok = szamok . map ( szam => szam * szam ); console . log ( negyzetszamok ); // [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] A filter() szint\u00e9n egy callback f\u00fcggv\u00e9nyt v\u00e1r param\u00e9terk\u00e9nt, \u00e9s a t\u00f6mbb\u0151l kiv\u00e1logatja azokat az elemeket, amelyek eleget tesznek a f\u00fcggv\u00e9ny t\u00f6rzs\u00e9ben megadott felt\u00e9telnek. A kiv\u00e1logatott elemeket egy \u00faj t\u00f6mbben kapjuk vissza. P\u00e9lda: Adott egy sz\u00e1mokat tartalmaz\u00f3 t\u00f6mb. V\u00e1logassuk ki a p\u00e1ros sz\u00e1mokat egy \u00faj t\u00f6mbbe! 1 2 3 4 5 6 7 8 let szamok = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]; // A callback f\u00fcggv\u00e9ny megad\u00e1s\u00e1ra ebben a k\u00f3dban az arrow function-\u00f6s szintaxist haszn\u00e1ltuk // A callback f\u00fcggv\u00e9nynek egyetlen param\u00e9tere van (szam), amely mindig az aktu\u00e1lis t\u00f6mbelemet jelk\u00e9pezi // A f\u00fcggv\u00e9ny t\u00f6rzs\u00e9ben megviszg\u00e1ljuk, hogy p\u00e1ros-e a sz\u00e1m, majd a p\u00e1ros sz\u00e1mokat kigy\u0171jtj\u00fck egy parosSzamok nev\u0171 t\u00f6mbbe let parosSzamok = szamok . filter ( szam => szam % 2 === 0 ); console . log ( parosSzamok ); // [2, 4, 6, 8, 10] Megjegyz\u00e9s: A p\u00e9ld\u00e1kban szerepl\u0151 feladatokat term\u00e9szetesen megoldhattuk volna hagyom\u00e1nyos m\u00f3don: vez\u00e9rl\u00e9si szerkezetekkel \u00e9s egy (kezdetben \u00fcres) t\u00f6mbbe val\u00f3 besz\u00farogat\u00e1ssal is. Viszont a map() \u00e9s filter() f\u00fcggv\u00e9nyek ismerete jelent\u0151sen egyszer\u0171bb k\u00f3dot eredm\u00e9nyez.","title":"T\u00f6mb\u00f6k"},{"location":"00_js_recap/#objektumok","text":"Az object adatt\u00edpussal property-\u00e9rt\u00e9k p\u00e1rokat t\u00e1rol\u00f3 objektumokat hozhatunk l\u00e9tre (a property-k tulajdonk\u00e9ppen az objektum adattagjai) L\u00e9trehoz\u00e1s: 1 2 let ures = {}; // \u00fcres objektum let szemely = { nev : \"B\u00e9la\" , kor : 20 , foglalkozas : \"programoz\u00f3\" }; Adott property-hez tartoz\u00f3 \u00e9rt\u00e9k lek\u00e9rdez\u00e9se: . vagy [] oper\u00e1torokkal A k\u00fcl\u00f6nbs\u00e9g a k\u00e9t oper\u00e1tor k\u00f6z\u00f6tt: ha egy v\u00e1ltoz\u00f3t adunk \u00e1t nekik, akkor a . oper\u00e1tor a v\u00e1ltoz\u00f3 nev\u00e9t , m\u00edg a [] oper\u00e1tor a v\u00e1ltoz\u00f3 \u00e9rt\u00e9k\u00e9t tekinti a property nev\u00e9nek Ha egy nem l\u00e9tez\u0151 property-hez tartoz\u00f3 \u00e9rt\u00e9ket k\u00e9r\u00fcnk le, akkor undefined -ot kapunk 1 2 3 4 5 6 7 8 let szemely = { nev : \"B\u00e9la\" , kor : 20 , foglalkozas : \"programoz\u00f3\" }; console . log ( szemely . nev ); // a nev property-hez tartoz\u00f3 \u00e9rt\u00e9k lek\u00e9r\u00e9se (1. verzi\u00f3) console . log ( szemely [ \"nev\" ]); // a nev property-hez tartoz\u00f3 \u00e9rt\u00e9k lek\u00e9r\u00e9se (2. verzi\u00f3) // a l\u00e9nyegi k\u00fcl\u00f6nbs\u00e9g a k\u00e9t oper\u00e1tor m\u0171k\u00f6d\u00e9s\u00e9ben let valami = \"foglalkozas\" ; console . log ( szemely . valami ); // a valami nev\u0171 property-hez tartoz\u00f3 \u00e9rt\u00e9k lek\u00e9r\u00e9se (nincs ilyen!) console . log ( szemely [ valami ]); // a foglalkozas nev\u0171 property-hez tartoz\u00f3 \u00e9rt\u00e9k lek\u00e9r\u00e9se A k\u00f3d kimenete B\u00e9la B\u00e9la undefined programoz\u00f3 Fontosabb m\u0171veletek objektumokon: Property el\u0151fordul\u00e1s\u00e1nak ellen\u0151rz\u00e9se Property-hez tartoz\u00f3 \u00e9rt\u00e9k m\u00f3dos\u00edt\u00e1sa \u00daj property-\u00e9rt\u00e9k p\u00e1r besz\u00far\u00e1sa Megl\u00e9v\u0151 property-\u00e9rt\u00e9k p\u00e1r t\u00f6rl\u00e9se 1 2 3 4 5 6 7 8 9 10 11 let szemely = { nev : \"B\u00e9la\" , kor : 20 , foglalkozas : \"programoz\u00f3\" }; if ( \"foglalkozas\" in szemely ) { // szerepel-a a foglalkozas property az objektumban console . log ( \"Ismerj\u00fck a foglalkoz\u00e1st.\" ); } szemely . nev = \"Sanyi\" ; // property-hez tartoz\u00f3 \u00e9rt\u00e9k m\u00f3dos\u00edt\u00e1sa szemely . szuletesiEv = 2000 ; // \u00faj property-\u00e9rt\u00e9k p\u00e1r besz\u00far\u00e1sa delete szemely . kor ; // megl\u00e9v\u0151 property-\u00e9rt\u00e9k p\u00e1r t\u00f6rl\u00e9se console . log ( szemely ); A k\u00f3d kimenete Ismerj\u00fck a foglalkoz\u00e1st. { nev: 'Sanyi', foglalkozas: 'programoz\u00f3', szuletesiEv: 2000 } Objektumok bej\u00e1r\u00e1sa: az Object.entries(obj) egy \"nagy\" t\u00f6mb\u00f6t ad vissza, amelynek minden eleme egy kisebb t\u00f6mb, amely az obj objektum egyik property-j\u00e9nek a nev\u00e9t \u00e9s az ahhoz tartoz\u00f3 \u00e9rt\u00e9ket t\u00e1rolja; ezen a \"nagy\" t\u00f6mb\u00f6n megy\u00fcnk v\u00e9gig egy for -ciklussal 1 2 3 4 5 6 7 8 9 10 11 let szemely = { nev : \"B\u00e9la\" , kor : 20 , foglalkozas : \"programoz\u00f3\" }; // Az Object.entries(szemely) tartalma a k\u00f6vetkez\u0151 t\u00f6mb: // [['nev', 'B\u00e9la'], ['kor', 20], ['foglalkozas', 'programoz\u00f3']] for ( let [ property , ertek ] of Object . entries ( szemely )) { // A bels\u0151 t\u00f6mb\u00f6k\u00f6n megy\u00fcnk v\u00e9gig, amelyek az egyes property-k nev\u00e9t \u00e9s \u00e9rt\u00e9k\u00e9t t\u00e1rolj\u00e1k // Ezeket sz\u00e9tszedj\u00fck: a property v\u00e1ltoz\u00f3ba ker\u00fcl a property neve, az ertek v\u00e1ltoz\u00f3ba pedig az \u00e9rt\u00e9ke console . log ( ` ${ property } \u00e9rt\u00e9ke: ${ ertek } ` ); } A k\u00f3d kimenete nev \u00e9rt\u00e9ke: B\u00e9la kor \u00e9rt\u00e9ke: 20 foglalkozas \u00e9rt\u00e9ke: programoz\u00f3","title":"Objektumok"},{"location":"00_js_recap/#egyeb-adatszerkezetek","text":"Lek\u00e9pez\u00e9s (map) : kulcs-\u00e9rt\u00e9k p\u00e1rok t\u00e1rol\u00e1sa Halmaz (set) : az elemeket ism\u00e9tl\u0151d\u00e9s n\u00e9lk\u00fcl t\u00e1rolja, \u00e9s az elemek k\u00f6z\u00f6tt nincs sorrendis\u00e9g","title":"Egy\u00e9b adatszerkezetek"},{"location":"00_js_recap/#objektumorientaltsag","text":"","title":"Objektumorient\u00e1lts\u00e1g"},{"location":"00_js_recap/#osztalyok-objektumok","text":"Oszt\u00e1ly: azonos tulajdons\u00e1ggal \u00e9s viselked\u00e9ssel rendelkez\u0151 objektumok \u00e1ltal\u00e1nos formai le\u00edr\u00e1sa (egy \"tervrajz\", ami alapj\u00e1n konkr\u00e9t objektumokat k\u00e9sz\u00edt\u00fcnk majd) L\u00e9trehoz\u00e1s: class kulcssz\u00f3val Az oszt\u00e1lyban adattagok \u00e9s met\u00f3dusok hozhat\u00f3k l\u00e9tre El\u00e9r\u00e9s\u00fck: . oper\u00e1torral A this kulcssz\u00f3val hivatkozhatunk mag\u00e1ra az objektumra - JavaScriptben a this -t mindig ki kell \u00edrni, ha egy adattagra vagy egy met\u00f3dusra hivatkozunk JavaScriptben az adattagokat a konstruktorban hozzuk l\u00e9tre (nem az oszt\u00e1ly t\u00f6rzs\u00e9nek elej\u00e9n) Konstruktor: az oszt\u00e1ly p\u00e9ld\u00e1nyos\u00edt\u00e1sakor (azaz egy objektum legy\u00e1rt\u00e1sakor) fut le L\u00e9trehoz\u00e1s: constructor() nev\u0171 met\u00f3dus defini\u00e1l\u00e1sa az oszt\u00e1lyon bel\u00fcl \u00c1ltal\u00e1ban az adattagok l\u00e9trehoz\u00e1s\u00e1ra \u00e9s inicializ\u00e1l\u00e1s\u00e1ra haszn\u00e1ljuk Objektumok: az oszt\u00e1lyokb\u00f3l val\u00f3 p\u00e9ld\u00e1nyos\u00edt\u00e1ssal hozhatjuk \u0151ket l\u00e9tre P\u00e9ld\u00e1nyos\u00edt\u00e1s szintaxisa: new OsztalyNeve(/* konstruktor param\u00e9terek... */) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Allat { // egy oszt\u00e1ly l\u00e9trehoz\u00e1sa constructor ( nev , kor ) { // konstruktor this . nev = nev ; // adattagok l\u00e9trehoz\u00e1sa \u00e9s inicializ\u00e1l\u00e1sa this . kor = kor ; } info () { // egy met\u00f3dus az oszt\u00e1lyon bel\u00fcl console . log ( ` ${ this . nev } egy ${ this . kor } \u00e9ves \u00e1llat.` ); } } let allat1 = new Allat ( \"Cs\u0151rike\" , 3 ); // oszt\u00e1ly p\u00e9ld\u00e1nyos\u00edt\u00e1sa (objektumok gy\u00e1rt\u00e1sa) let allat2 = new Allat ( \"Szilveszter\" , 5 ); allat1 . info (); // info() met\u00f3dus megh\u00edv\u00e1sa az adott objektumra allat2 . info (); A k\u00f3d kimenete Cs\u0151rike egy 3 \u00e9ves \u00e1llat. Szilveszter egy 5 \u00e9ves \u00e1llat.","title":"Oszt\u00e1lyok, objektumok"},{"location":"00_js_recap/#lathatosagok-getterek-setterek","text":"JavaScriptben nincsenek az adattagok l\u00e1that\u00e1s\u00e1t szab\u00e1lyoz\u00f3 m\u00f3dos\u00edt\u00f3szavak, alapb\u00f3l minden adattag \u00e9s met\u00f3dus publikus l\u00e1that\u00f3s\u00e1g\u00fa Konvenci\u00f3 alapj\u00e1n a nem publikus haszn\u00e1latra sz\u00e1nt adattagok neve el\u00e9 _ (alulvon\u00e1s) karakter \u00edrunk (de ett\u0151l m\u00e9g k\u00edv\u00fclr\u0151l ugyan\u00fagy el\u00e9rhet\u0151!) Az getterek \u00e9s setterek megval\u00f3s\u00edt\u00e1sa property-kkel t\u00f6rt\u00e9nik Getter l\u00e9trehoz\u00e1sa egy adattag \u00e9rt\u00e9k\u00e9nek lek\u00e9r\u00e9s\u00e9re: get property-vel Setter l\u00e9trehoz\u00e1sa egy adattag \u00e9rt\u00e9k\u00e9nek be\u00e1ll\u00edt\u00e1s\u00e1ra: set property-vel Olyan, mintha egy teljesen \u00faj adattag j\u00f6nne l\u00e9tre az objektumon bel\u00fcl Nagyon fontos, hogy a getter/setter neve \u00e9s az adattag neve mindig elt\u00e9r\u0151 legyen, k\u00fcl\u00f6nben v\u00e9gtelen rekurzi\u00f3ba futunk! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Allat { constructor ( nev , kor ) { this . nev = nev ; this . _kor = kor ; // nem publikus haszn\u00e1latra sz\u00e1nt adattag } get kor () { // getter return this . _kor ; } set kor ( ertek ) { // setter if ( ertek < 1 ) console . log ( \"HIBA: Pozit\u00edv sz\u00e1mot adj meg!\" ); else this . _kor = ertek ; } info () { console . log ( ` ${ this . nev } egy ${ this . kor } \u00e9ves \u00e1llat.` ); } } let allat1 = new Allat ( \"Garfield\" , 6 ); let allat2 = new Allat ( \"Ubul\" , 5 ); allat1 . kor = 8 ; // set property h\u00edv\u00e1sa allat2 . kor = - 1 ; console . log ( allat1 . kor ); // get property h\u00edv\u00e1s allat1 . info (); allat2 . info (); A k\u00f3d kimenete HIBA: Pozit\u00edv sz\u00e1mot adj meg! 8 Garfield egy 8 \u00e9ves \u00e1llat. Ubul egy 5 \u00e9ves \u00e1llat.","title":"L\u00e1that\u00f3s\u00e1gok, getterek, setterek"},{"location":"00_js_recap/#oroklodes","text":"Oszt\u00e1lyok k\u00f6z\u00f6tti kapcsolat, amely egy \u0151soszt\u00e1ly \u00e9s egy gyermekoszt\u00e1ly k\u00f6z\u00f6tt val\u00f3sul meg. A gyermekoszt\u00e1ly tulajdonk\u00e9ppen az \u0151soszt\u00e1lynak egy speci\u00e1lis v\u00e1ltozata lesz (pl. a Macska oszt\u00e1ly az Allat oszt\u00e1ly gyermeke, hiszen minden macska egyben \u00e1llat is). A gyermekoszt\u00e1ly meg\u00f6r\u00f6kli az \u0151soszt\u00e1ly \u00f6sszes adattagj\u00e1t \u00e9s met\u00f3dus\u00e1t A gyermekoszt\u00e1ly az \u00f6r\u00f6k\u00f6lteken k\u00edv\u00fcl \u00fajabb adattagokat \u00e9s met\u00f3dusokat is tartalmazhat A gyermekoszt\u00e1ly fel\u00fcldefini\u00e1lhatja egy \u00f6r\u00f6k\u00f6lt met\u00f3dus m\u0171k\u00f6d\u00e9s\u00e9t ( overriding ) \u00d6r\u00f6kl\u0151d\u00e9s JavaScriptben: Szintaxisa: class GyermekOsztaly extends OsOsztaly JavaScriptben csak egyszeres \u00f6r\u00f6kl\u0151d\u00e9s lehets\u00e9ges! Ez azt jelenti, hogy egy gyermekoszt\u00e1lynak nem lehet 1-n\u00e9l t\u00f6bb \u0151se A gyermekoszt\u00e1lyban a super kulcssz\u00f3val hivatkozhatunk az \u0151soszt\u00e1lyra 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Allat { // \u0151soszt\u00e1ly constructor ( nev , kor ) { this . nev = nev ; this . _kor = kor ; } get kor () { return this . _kor ; } set kor ( ertek ) { if ( ertek < 1 ) console . log ( \"HIBA: Pozit\u00edv sz\u00e1mot adj meg!\" ); else this . _kor = ertek ; } info () { console . log ( ` ${ this . nev } egy ${ this . kor } \u00e9ves \u00e1llat.` ); } eszik ( mit ) { console . log ( ` ${ this . nev } \u00e9ppen eszi ezt: ${ mit } .` ); } } class Macska extends Allat { // gyermekoszt\u00e1ly constructor ( nev , kor , fajta ) { super ( nev , kor ); // \u0151soszt\u00e1ly konstruktor\u00e1nak megh\u00edv\u00e1sa this . fajta = fajta ; } dorombol () { console . log ( \"PURR!\" ); } // overriding: \u0151soszt\u00e1lyb\u00f3l \u00f6r\u00f6k\u00f6lt met\u00f3dus m\u0171k\u00f6d\u00e9s\u00e9nek fel\u00fcl\u00edr\u00e1sa info () { console . log ( ` ${ this . nev } egy ${ this . fajta } macska.` ); } } let macska = new Macska ( \"Cirmi\" , 3 , \"perzsa\" ); macska . eszik ( \"tonhal\" ); macska . dorombol (); macska . info (); A k\u00f3d kimenete Cirmi \u00e9ppen eszi ezt: tonhal. PURR! Cirmi egy perzsa macska.","title":"\u00d6r\u00f6kl\u0151d\u00e9s"},{"location":"00_js_recap/#tipusellenorzes","text":"Egyszer\u0171bb t\u00edpusok (boolean, number, string, object, function) eset\u00e9n: typeof val === \"type\" (visszaadja, hogy a val \u00e9rt\u00e9k type t\u00edpus\u00fa-e) T\u00f6mb\u00f6k \u00e9s oszt\u00e1lyb\u00f3l p\u00e9ld\u00e1nyos\u00edtott objektumok eset\u00e9n: obj instanceof Osztaly (visszaadja, hogy obj az Osztaly p\u00e9ld\u00e1nya-e) A t\u00f6mb\u00f6k az Array be\u00e9p\u00edtett oszt\u00e1ly p\u00e9ld\u00e1nyai 1 2 3 4 5 6 7 8 9 10 11 12 console . log ( typeof 42 === \"number\" ); // true console . log ( typeof 42 === \"string\" ); // false let tomb = [ 10 , 20 , 30 , 40 , 50 ]; console . log ( tomb instanceof Array ); // true class Kutya { constructor ( nev , kor , fajta ) { /* ... */ } } let kutya = new Kutya ( \"Rex\" , 4 , \"n\u00e9metjuh\u00e1sz\" ); console . log ( kutya instanceof Kutya ); // true","title":"T\u00edpusellen\u0151rz\u00e9s"}]}